Dokumentacja

1. Opis ogólny projektu:
Projekt jest grą, o nazwie Battleship, która jest odtwarzana w oknie konsoli programu. Battleship jest grą typu strategiczno-planszowego przeznaczoną dla dwóch osób. Gra ta polega na toczeniu bitew pomiędzy dwoma graczami, którzy muszą zatopić wszystkie statki swojego wroga. Wygrywa ta osoba, która zatopi wszystkie statki swojego przeciwnika. Projekt ten został napisany w języku programowania C#. Jego struktura opiera się na programowaniu obiektowym. Gra nieco różni się od oryginału, czego przejawem jest regulacja niektórych zasad. Zabieg ten ma na celu zwiększenie elastyczności i efektywności rozgrywki oraz stanowi swego rodzaju oryginalny pomysł na rozgrywkę.

2. Cele projektu:
Głównym celem projektu jest przede wszystkim wzbudzenie ciekawości i zachwytu u osób rozpoczynających naukę programowania, bądź osób, które planują ów naukę oraz zaprezentowanie im możliwości języka C# wykorzystując do tego podstawową znajomość składni ów języka, w tym: właściwości, metod i klas. Bardzo często, jak nie zawsze programy konsolowe i ich tworzenie wprawia nowicjuszy programowania w osłupienie i agonię, związane z zetknięciem się z nigdy dotąd nieznanym środowiskiem programistycznym oraz językiem programowania, którego działania ci nowicjusze nie rozumią w znacznej części, bądź wcale. Sposób działania gry, jak również jej funkcje mają zachęcić tych ludzi do podjęcia solidnej i wytężonej nauki programowania oraz zwiększyć w nich chęć trwania w tejże nauce. Pomijając główny cel, projekt ten stanowi także źródło rozrywki i relaksu dla dwóch osób.

3. Informacje o autorze:
Autorem programu jest: Patryk Szewczyk - uczeń Akademii Handlowej Nauk Stosowanych 1 semestru na kierunku: Informatyka. Autor zakazuje kopiowania i udostępniania gry, korzystania z niej w celach marketingowych i sprzedawania jej jako samodzielnego produktu.

4. Struktura programu:
Cały program jest napisany w oparciu o programowanie obiektowe. Program składa się z dwóch przestrzeni nazw odpowiedzialnych za dołączenie do programu odpowiednich bibliotek oraz dwóch przestrzeni nazw zawierających na kod programu: "OutputProgram" i "InputWorkProgram". W przestrzeni "OutputProgram" znajduje się główna klasa programu "Program" ze swoją główną metodą "Main(string[] arg)", która wywołuje proceduralnie kod, w którym znajdują się polecenia dotyczące tworzenia instancji klas z przestrzeni "InputWorkProgram", która pełni funkcję przestrzeni wykonawczej. Przestrzeń wykonawcza jest przestrzenią, w której wykonywane są wszystkie operacje odnośnie gry. W grze wielokrotnie jest użyta pętla "while", która pełni funkcję ponownego wykonania danego bloku kodu, dzięki czemu możliwe jest wykonanie takich operacji jak ponowne ułożenie statku, jeżeli źle go ułożono, jak również umożliwia ponowną grę po zakończeniu bieżącej.

5. Instrukcja obsługi:
Każdy z graczy posiada po dwie plansze o wielkości, 10x10 pól. Pola oznaczone są poprzez współrzędne literami od "A" do "J" i liczbami "0" do "9". Każdy gracz posiada siedem statków, które posiadają długość od 2 do 5 pól planszy. Początkiem gry jest ekran tytułowy z podstawowymi informacjami odnośnie gry, który wprowadza graczy do niej. Gracze przechodzą na następną stroną klikając klawisz "Enter". Czynności tego typu jest bardzo dużo. Drugą stroną jest instrukcja obsługi gry. Później gracze przechodzą do ustawiania swoich statków na swoich planszach. Statki mogą być ustawiane w poziomie i pionie oraz muszą spełniać dwa warunki.
    1. Nie mogą wychodzić poza plansze.
    2. Nie mogą nakładać się na siebie.
Strona na przedstawia się następująco: u góry znajduje się nazwa gracza, pod nią plansza danego gracza, a pod nią informacje o aktualnym statku tego gracza. Informacje prezentują się następująco:
    1. Typ statku.
    2. Długość statku.
    3. Kierunek statku.
    4. Współrzędne statku.
Dwie ostatnie właściwości statku jako wartość mają "?", co oznacza niewiadomą. Te dwie właściwości trzeba uzupełnić przy stawianiu tych statków. Jako pierwszy należy podać kierunek statku. Do wybory jest: "R" (right) i "B" (bottom). "R" oznacza położenie poziome, a "B" położenie pionowe. Jeżeli gracz ułoży statek na pozycji R, to będzie zajmował pola w kierunku "A2", "A3", "A4", itd., natomiast jeżeli gracz poda "B", to statek będzie zajmował pola w kierunku "A2", "B2", "C2". Drugą i ostatnią rzeczą do ustalenia jest początkowe położenie statku. Położenie to określa punkt pola planszy od którego statek będzie "tworzony" względem wybranego kierunku ("R" lub "B"). Po ustawieniu statków gracze przechodzą do strony z bitwą. Na stronie z bitwą od góry znajdują się dwie plansze obu graczy z ich nazwą znajdującą się u góry tych planszy. Dalej znajdują się informacje o statkach, które przechowują ukryte współrzędne statków obu graczy. Na dole znajduje się obszar wyświetlania zapytań. Na początku bitwy gracze ustalają kto ją rozpoczyna, a następnie po tej decyzji rozpoczyna się bitwa. W bitwie gracze strzelają na przemian do siebie, w celu zniszczenia wszystkich statków swojego wroga. Wygrywa ten gracz, który jako pierwszy zniszczy wszystkie statki swojego wroga. Jeżeli któryś z graczy trafi któryś ze statków swojego przeciwnika, gracz ten może strzelić ponownie. Ta aktywność powtarza się dopóki gracz ten chybi, nie trafiając w statek swojego wroga. Informacje o graczy który atakuje są widoczne w dwóch miejscach: na górze jako strzałka do nazwy gracza oraz u dołu w komunikacie. Trafienie okrętu przeciwnika polega na strzale, który jest odgadnięciem położenia jakiegoś statku. Strzały oddawane są naprzemiennie, poprzez podanie współrzędnych pola (np. "B5"). Trafienie statku jest oznaczane znakiem "X". O chybieniu informuje gracza znak "O" pojawiający się na polu, które ostrzeliwał. Zatopienie statku ma miejsce wtedy, kiedy gracz trafi we wszystkie pola zajmowane przez ten statek. Wówczas w informacjach o statkach przeciwnika pokażą się współrzędne statku, który gracz zniszczył. Po skończonej bitwie gracze przechodzą do strony z nagrodą, gdzie wyświetla się zapytanie o ponowną grę. Gracze mają możliwość ponownego stocznia bitwy i zakończenia gry, przechodząc do napisów końcowych. Kiedy gracze wybiorą drugą opcję, przejdą do strony, na której znajdują się informacje o twórcy gry. Znajduje się tam także informacja o zakończeniu programu, kiedy kliknie się klawisz "Enter".

6. Działanie programu:
Działanie programu rozpoczyna się i kończy tylko i wyłącznie w metodzie "Main()" klasy "Program", wyjściowej przestrzeni nazw "OutputProgram". Lecąc od samej góry tworzymy instancje poszczególnych klas z wykonawczej przestrzeni nazw "InputWorkProgram". Kiedy wywołamy metodę danej instancji, przechodzimy do danej metody danej klady wykonawczej przestrzeni nazw. W wykonawczej przestrzeni nazw w celu uporządkowania kodu użyto dziedziczenia do wskazania które klasy są nadrzędna, a które potomne. Mapa dziedziczenia klas przedstawia się następująco:
Program ------ Game Intro,
                        GameLoop, ------ GameProper, ------ BoardContentMaker,
                        GameCredits        Prize                       ShipBuildChecker,
                                                                                    ShipCannon 
W praktyce dziedziczenie nie jest w ogóle potrzebne, ale tak jak napisano powyżej ma ono zasadnicze znaczenie w porządkowaniu klas. 
Kod programu jest kompilowany i wywoływany od góry do dołu tylko i wyłącznie w klasie Program, a jako że znajdują się w niej polecenia dotyczące utworzenia instancji trzech klas potomnych i wywołania ich metod, program zatrzyma się na instancji GameLoop, aby utworzyć wszystkie instancje klas potomnych z klasy "GameLoop", wykona ich metody i dopiero ruszy dalej do utworzenia instancji klasy GameCredits. Reasumując, patrząc na mapę widać, że zanim program dotrze do utworzenia instancji klasy "GameCredits" i wywołania jej metody, utworzy wszystkie instancje klas potomnych klasy "GameLoop".
Szczególną uwagę trzeba zwrócić na klasę "GameLoop" która jest jedną wielką pętlą, umożliwiającą na ponowną grę, kiedy gracze zdecydują się ponownie zagrać, po uprzednio zakończonej sesji. W klasach potomnych tejże klasy ("GameProper", "Prize") mamy do czynienia z kolejnymi pętlami, a w "GameProper" aż z kilkoma zagnieżdżonymi, dzięki którym przy małym nakładzie kodu można wyznaczyć statki dla dwóch grach, zresetować współrzędne danego statku, jak również całą grę, w celu ponownego zagrania w nią.

7. Technologie i Biblioteki:
Program został napisany w całości w języku programowania C# bez użycia frameworków. W programie znajdują się dwie przestrzenie nazw odpowiedzialnych za dołączanie określonych bibliotek. Są to kolejno: System i System.Collections.Generic.
"System" – zawiera podstawowe typy i klasy, takie jak "Console", czy "String".
"System.Collections.Generic" – oferuje generyczne kolekcje, takie jak dynamiczne listy "List", z których można usuwać indeksy i je dodawać.

8. Szczegółowy opis zawartości przestrzeni nazw "OutputProgram":
Przestrzeń nazw "OutputProgram" jak to zostało wcześniej napisane posiada tylko jedną klasę i metodę, która wykonuje proceduralnie następujące linie kodu. W "OutputProgram" tworzy się instancje klas z przestrzeni nazw "InputWorkProgram", które pełnią swego rodzaju funkcję poszczególnych komponentów tego programu. Komponenty te można wywołać w dowolnej kolejności z tym samym efektem, co w ustalonej w programie kolejności. Dzieje się tak z tego względu, iż pomiędzy metodami instancji klas przestrzeni nazw "InputWorkProgram" nie ma żadnego przekazywania zwracanych wartości.
W metodzie "Main" klasy "Program" przestrzeni nazw "OutputProgram" są tworzone trzy instancje poszczególnych klas: "GameIntro", "GameLoop" i "GameCredits". Klasy te znajdują się w wykonawczej przestrzni nazw "InputWorkProgram".
Klasa "GameIntro" "intro()" odpowiada za wyświetlenie wprowadzenia do gry, w którym znajdują się kolejno: tytuł gry, licencja, informacja o grze, prośba o maksymalizację okna konsoli i komunikat o przejściu dalej. Komunikatów o przejściu dalej jest cała masa. Aby przejść dalej należy kliknąć przycisk "Enter". Metoda "insruction()", odpowiada za wyświetlenie instrukcji gry, wraz z komunikatem o przejściu dalej.
Klasa "GameLoop" odpowiada za wywoływanie "właściwego" kodu gry w pętli, dopóki gracze po zakończonej rozgrywce zdecydują się zakończyć grę. Szczegóły odnośnie tej klasy i jej klas potomnych będą omówione dalej.
Klasa "GameCredits" wyświetla informacje o zakończeniu gry, w tym podziękowania, informacje o autorze i komunikat o zakończeniu programu po kliknięciu klawisza "Enter".

9. Klasy przestrzeni nazw "InputWorkProgram":
W "InputWorkProgram" realizowane są wszystkie operacje związane z grą. Działanie programu w tej przestrzeni opiera się na tworzeniu danych instancji klas i wywoływaniu ich metod. Tak przedstawia się plan klas i kierunek wywoływania kodu odnośnie klas:
Game Intro,
GameLoop, ------ GameProper, ------ BoardContentMaker,
GameCredits        Prize                       ShipBuildChecker,
                                                            ShipCannon 
Zaczynając od samej góry program tworzy instancję klasy "GameIntro" i wywołuje jej metody. Następnie idzie do klasy "GameLoop" i robi dokładnie to samo, z tą różnicą, iż tworzy w niej instancje klas "GameProper" i Prize, gdzie wywołuje także ich metody. Po wywołaniu ich metod program przechodzi do "GameCredits", gdzie kończy się gra. W "GameProper" dzieje się to samo co w "GameLoop" - program tworzy instancje klas potomnych "BoardContentMaker", "ShipBuildChecker" i "ShipCannon" klasy nadrzędnej "GameProper".
Poniżej znajduje się szczegółowy opis wszystkich klas i ich metod z przestrzeni nazw "InputWorkProgram" w kolejności wykonywania programu.

10. Klasa "GameIntro":
"GameIntro" odpowiada za wyświetlenie wprowadzenie do gry oraz instrukcji obsługi gry. Klasa ta ma dwie metody, którymi są "intro()" i "instruction()".
Metoda "intro()" wyświetla na samej górze tytuł gry, który jest napisany w znakach "B". Dalej wyświetla tytuł gry pisany "normalnie" oraz informacje o prawach autorskich. Następnie ukazuje krótki opis gry, wyjaśniający na czy ona polega. Następnie ostrzega użytkownika o błędach, które pojawią się, gdy ten nie zmaksymalizuje swojego ekranu konsoli, w celu pełnego kasowania jej zawartości. Na końcu tej metody znajduje się komunikat, który informuje gracza, że aby przejść dalej trzeba nacisnąć klawisz "Enter". Takich komunikatów jest bardzo dużo w programie, gdyż odpowiadają one za uniemożliwienie niekontrolowanego przejścia dalej, aby np. gracz nie został przeniesiony automatycznie dalej, czego skutkiem byłoby nie dostrzeżenie przez niego przykładowo instrukcji obsługi gry, gdyż zmiana strony nastąpiłaby w zbyt krótkim odstępie czasu, aby gracz mógł wychwycić stronę z instrukcją.
Metoda "instruction()" powoduje wyświetlenie się napisu "INSTRUCTION" składającego się ze znaków "B" i 17 punktów, które mówią o zasadach gry. Na końcu tak jak przy każdej stronie, bądź przy danym etapie pojawia się komunikat o przejściu dalej - tutaj o przejściu do pozycjonowania statków na planszach graczy.

11. Klasa "GameLoop":
W klasie "GameLoop" znajduje się jedna metoda o nazwie "activeGameLoop()". Służy ona do włączania wywoływania gry w pętli, dopóki gracze zdecydują się ją zakończyć w metodzie "winnerInfo()" klasy "Prize".
Na początku instrukcji pętli program tworzy instancję klasy "GameProper", a następnie wywołuje jej pierwszą metodę – "setPlayerShips()". Metoda ta jest odpowiedzialna za wywołanie wszystkich niezbędnych zapytań oraz operacji z nimi związanych, które mają na celu pobranie od graczy informacji niezbędnych do ustawienia poszczególnych statków. Metoda ta zwraca tablicę trójwymiarową współrzędnych poszczególnych statków obu graczy do klasy "GameProper", a dokładniej do zmiennej "playerShipCoorData_AR", która jest przekazywana jako argument kolejnej metody tej instancji "GameProper") o nazwie "fight()". Metoda "fight()" odpowiada za przeprowadzenie bitwy pomiędzy dwoma graczami. Dzięki przekazaniu trójwymiarowej listy współrzędnych program może na ich podstawie wykonać logikę strzelania gry według ustalonych dla niej instrukcji, w tejże metodzie. Po zakończeniu bitwy "fight()" zwraca informację o zwycięzcy gry do klasy "GameProper" do zmiennej "winner". Pętli gry utworzona zostaje instancja klasy "Prize", a następnie zostaje wywołana jej metoda "winnerInfo()" do której jest przekazywana zmienna "winner", zawierająca informację o zwycięzcy. Metoda "winnerInfo()" wyświetla określony tytułowy komunikat o wygranej (złożony z liter "B"), w zależności od wartości parametru tej metody, czyli informacji o graczu.

12. Klasa "GameProper":
Klasa "GameProper" zawiera dwie klasy: "setPlayersShips()" i "fight()". Obie te metody zwracają po jednej zmiennej do klasy nadrzędnej "GameLoop", do określonych w niej zmiennych, o których była już mowa.
Metoda "setPlayersShips()" odpowiada za wszystkie zapytania i operacje dotyczące określania pozycji statków przez graczy oraz przekazywania tych informacji do metody "ShipBuildChecker" instancji "shipCoorBuildChecker", w celu walidacji danych (współrzędnych), i dodawania ich na bieżąco do tablicy współrzędnych statków graczy jako zbite łańcuchy znaków, a następnie do metody "updateBoardContent" klasy "BoardContentMaker" w celu aktualizacji planszy graczy i tablicy współrzędnych statków graczy.
Działanie metody "setPlayersShips()", jak również sąsiedniej o nazwie "fight()"  i innych, które są wywoływane przez główną pętlę (w metodzie "activeGameLoop()" z klasy "GameLoop") jest bardzo skomplikowane, przez co na dokładne opisanie ich we wszystkich szczegółach trzeba byłoby poświęcić co najmniej 40 stron dokumentacji. W związku z tym faktem przyjęto twierdzenie, iż czytelnik posiada znajomość przynajmniej jednego języka programowania, w stopniu, w którym może on swobodnie z niego korzystać do programowania różnych rzeczy w umiarkowanym stopniu trudności.
Na początku metody "setPlayersShips()" mamy deklarację zmiennych, z których trzy są tworzone w oparciu o wywołanie odpowiedniej metody z instancji "BoardContentMaker()". Zmiennymi są następująco: 
    1. Tablica string[,] "playersShipCoor" – która przechowuje współrzędne poszczególnych statków wszystkich graczy. Użyto tu typu tablicy dwuwymiarowej string[,], gdyż, w przeciwieństwie do listy List<List<string> można swobodnie wrzucać poszczególne wartości do jej indeksów. Struktura danych tej tablicy wygląda następująco: gracz → współrzędne statku. Współrzędne statku są łańcuchem znaków (typ string) takim jak: "A2|B2|C2". Znaki "|" w ów łańcuchach znaków są użyte jako specjalny rodzaj identyfikatorów, które wykrywane w metodzie "fight()", służą do rozdzielania poszczególnych wartości indeksów tablicy dwuwymiarowej, które wkładane są do listy trójwymiarowej jako rozdzielone od siebie współrzędne, w celu umożliwienia przeprowadzenia na nich logiki strzelania. Można by przecież od razu włożyć współrzędne statków do listy trójwymiarowej, ale oznaczałoby to jeden zasadniczy problem. Ogólnie w logice strzelania i "tworzenia" statków wykorzystuje się skonwertowane współrzędne, które z formy "B2" i "D7" przybierają formę "12" i "37". Włożenie współrzędnych od razu do listy trójwymiarowej oznaczałoby potrzebę ponownego ich wyjęcia w celu konwersji danych na numeryczny rodzaj wartości. Z drugiej strony włożenie danych od razu z konwersją spowodowałoby, iż na panelu informacji o położeniu danego statku, jak również podczas bitwy gracze widzieliby współrzędne statków wyrażone w cyfrach, a nie w postaci „A2 | B2”, czy „E4 | E5 | E6”. Można by od razu zrobić odpowiednie konwersje na wszystkie rodzaje wartości w metodzie "playersShipCoor()", albo wcześniej w "shipCoorBuildChecker()" klasy "ShipBuildChecker" i zwrócić wszystkie te listy do klasy "GameProper". Takie rozwiązanie wprowadziłoby zamęt i dezorientacje w zwracaniu zmiennych i nie byłoby zgodne z ideą operacji metody, więc zostawiono dane "D2 | D3" w postaci nienaruszonej.
    2. Tablica string[,,] "playersBoardContent_AR", zawierająca graficzny układ planszy dla obu graczy, wykorzystywany w tej metodzie do pokazywania położenie aktualnie ustawionych statków. Jej struktura przedstawia się tak: plansza → rząd (wiersz) → indeks rzędu. Pierwszy wymiar "2" oznacza planszę przypadającą na danego gracza. Dwa pozostałe odpowiadają za wymiary planszy 10 x 10. Wartością początkową dla każdego indeksu tablicy "playersBoardContent" jest "~".
    3. Dwuwymiarowa lista List<List<int>> "fullIndex_AR" przechowuje listę wartości liczb całkowitych od 0 do 99 dla dwóch graczy, które odpowiadają wszystkim indeksom z tablicy graficznej obu plansz. Użyto tu listy „List”, gdyż oferuje on możliwość dynamicznego zmieniania liczby indeksów tablicy, co w przypadku tablicy string[,] jest niemożliwe. Istnieje wprawdzie sposób na obejście tego problemu, w postaci tworzenia nowej tablicy z odpowiednią liczbą indeksów z odpowiednimi wartościami, lecz jest on bardzo trudny do zaaplikowania. Zmiana struktury tablicy jest potrzebna do mechaniki ustawiania statków i strzelania do nich.
    4. Trójwymiarowa lista List<List<List<int>>> "dangerFields_AR" przechowuje wszystkie niedozwolone pola na ustawianie statków względem ich długości. Ustawienie statków polega na wyznaczeniu kierunku tworzenia statku – w dół i na prawo oraz współrzędnej początkowej, od której jest tworzony statek za pomocą metody "shipCoorBuildChecker()" z klasy "ShipBuildChecker". W metodzie tej znajdują się walidacje współrzędnych. Jedna z nich dotyczy nie wychodzenia współrzędnych poza planszę. Kiedy tworząc statek o długości dwóch w dół podałoby się "J7", to logicznie rzecz biorąc statek ten miałby współrzędne "J7 | K7". Jako że dziesiątą literą od "A" jest "J", statek wyszedłby poza planszę, co spowodowałoby niemiłe zaskoczenie. W celu uniknięcia takiej sytuacji przeprowadzana jest walidacja wszystkich współrzędnych wykorzystując w tym celu pola niedozwolone dla statku o danym kierunku położenia i długości. Struktura tablicy wygląda następująco: kierunek → długość → zestaw niedostępnych pól → niedostępne pole
    5. int "players" przechowująca liczbę odpowiadającą danemu graczowi, która go identyfikuje w metodach w których są używane tablice, zawierające wartości dla obu graczy. Wartość dla gracza pierwszego wynosi 0, a dla drugiego 1.
    6. int "shipPage" jest podobna do "players", z tą różnicą, iż odpowiada ona statkom poszczególnych graczy. Zostaną ustawione wszystkie statki dla danego gracza, wartość zmiennej "shipPage" jest resetowana i wynosi 0.
    7. int "shipPageIncrement" inkrementuje zmienną "shipPage", kiedy zostaną zakończone wszystkie operacje dla ustawiania danego statku. Zmienna ta na początku jest nieaktywna, tzn. ma wartość 0. Spowodowane jest to tym, iż kiedy zakończy się dana operacja, np. wyznaczania kierunku statku, pętla wykonuje się od nowa w celu aktualizacji informacji o kierunku statku w panelu informacji statku w części gry odpowiedzialnej za ustawianie statków. Kiedy jej wartość wzrasta o 1 wszystkie zapytania o położenie dotyczą następnego statku.
    8. Tablica string[] "shipTypeName_AR" przechowuje tekstowe typy statków. Każdy kolejny typ to jeden statek.
    9. Tablica string[] "shipLengthName_AR" przechowuje długość statków. Jeden indeks tej tablicy przypada na jeden statek. Długość statku jest liczbą pól planszy przypadającą na pole statku. Przykładowo, jeżeli długość statku wynosi 4, to będzie on zajmował cztery współrzędne na planszy.
    10. string "selectDirection" przechowuje kierunek statku, który określa jak przebiega tworzenie statku. Zmienna ta przyjmuje dwie wartości – "B" i "R". "B" to skrót z angielskiego, oznaczający "bottom", czyli dół. "selectDirection" o wartości "B" oznacza, że statki są tworzone do dołu od miejsca wyznaczenia punktu współrzędnej początkowej, która to określa pole na planszy, od którego ma być umieszczony statek. Przykładowo Kiedy wyznaczymy "A2" dla statku o długości 3, dostaniemy współrzędne "A2|B2|C2". W przypadku wartości "R" ("right" - prawo) zmiennej "selectDirection" statek umieszczany jest w kierunku prawym od wyznaczenia współrzędnej początkowej. Dla przykładu statek o długości 4 będzie miał współrzędne: "F4|F5|F6|F7".
    11. Zmienne typu bool: "isSetPlayerShipCoor", "isDirCoor", "isDir", "isBegAgn_FromDir", "isCoor" i "isDone" pełnią swego rodzaju funkcję przełączników, które włączają i wyłączają z obiegu wywoływanie danych fragmentów kodu. Oto za co odpowiadają te bool’e:
       "isSetPlayerShipCoor" – komunikat o ustawieniu wszystkich statków dla danego gracz i reset wszystkich zmiennych związanych z ustawianiem wszystkich statków, aby można było je ustawić od nowa.
       "isDirCoor" – wyłączenie formularzy ustawiania kierunku oraz punktu współrzędnej początkowej statku i włącznie zapytania o zapisanie danych dotyczących pozycji statku.
       "isDir"– formularz dotyczący ustawiania kierunku statku.
       "isBegAgn_FromDir" – włącznie i wyłączenie z obiegu informacji nakazujące umieszczenie siedmiu statków na planszy danego gracza. Komunikat ten pojawia się jednorazowo na początku serii ustawiania statków przez graczy.
       "isCoor" – formularz dotyczący ustawiania punktu współrzędnej początkowej statku.
       "isDone" – jest zmienną przeznaczoną na prawidłowe wyświetlanie komunikatu "?" dla nieokreślonych współrzędnych dla danego statku w panelu ustawiania ich na planszy, a dokładniej w sekcji związanej w wyznaczaniem współrzędnej początkowej. Wartość ta odnosi się do sytuacji w której utworzony statek wraz ze współrzędnymi nie przeszedł walidacji współrzędnych. Zmienna ta pełni niemal tą samą funkcję co wartość pierwszego indeksu "shipFullCoor" wynosząca "?", która odpowiada za wskazywanie zapytań które muszą być ponownie wykonane gdy wybrano złą współrzędną początkową, która to nie przeszła testów poprawności współrzędnych statku. Można by zadać pytanie dlaczego utworzono zmienną "isDone" dającą "taki" sam efekt. Powód użycia "isDone" jest bardzo złożony. "isDone" jak zostało wcześniej napisane odpowiada za prawidłowe wyświetlanie komunikatu "?" dla nieokreślonych współrzędnych dla danego statku w panelu informacyjnym ustawiania statków w sekcji wyznaczania współrzędnej początkowej. Gdyby użyto tam "shipFullCoor[0] = "?", wówczas podczas ponownego ustawiania współrzędnej początkowej w panelu informacyjnym w linii dotyczącej ustawionych współrzędnych zamiast znaku zapytania "?" znajdowałby się ciąg znaków " | | …" w zależności od długości statku. Jest to najtrudniejsza do zrozumienia część działania kodu, ponieważ shipFullCoor[0] = "?" i "isDone" odnoszą się do sytuacji w której utworzono złe współrzędne statku i następuje reset pętli odpowiedzialnej za zapytania odnośnie położenia tego statku. Ze względu na logikę warunków instrukcji warunkowych nie było możliwe zastosowanie wyłącznie operandu shipFullCoor[0] = "?" do wskazania kiedy wykonać odpowiednią operację, w tym operację pokazania znaku "?" w opisanej już sytuacji. Zmienna "isDone" ma zasadniczą właściwość, dzięki której można uzyskać pożądany efekt. Jest nią fakt, że nie jest zmienną shipFullCoor[0] = "?" przez co nie ma tzw. kolizji wartości zmiennych i dzięki temu wykonywane są poprawne operacje we wszystkich warunkach instrukcji warunkowych.
    12. string "firstCoor" zawiera wybrany przez gracza punkt współrzędnej początkowej, na podstawie której wyznaczane są pełne współrzędne statku, w zależności od ustalenia kierunku jego położenia.
    13. string[] "shipFullCoor" przechowuje łańcuch znaków, który stanowi współrzędne położenia danego statku.
    14. string "wantSave" służy jako wartość zapytania pytającego gracza czy chce zapisać dane położenia statku. Danymi tymi są przede wszystkim kierunek statku i jego już wyznaczone współrzędne. "wantSave" przyjmuje dwie wartości – "yes" i "no". Jeżeli gracz zdecyduje się na zapisanie danych, wówczas na jego planszy pojawia się statek na tych polach planszy, jakie były opisane we współrzędnych. Jeśli natomiast gracz odmówi zapisania danych wybierając "no", program powtórzy wszystkie operacje dla wyznaczania bieżącego statku. Wartością początkową jest "none", która oznacza nic i nie wpływa na nic.
    15. Tablica string[] "letCoorName" służy do przechowywania dużych liter, które są wyświetlane w iteracji pętli odpowiedzialnej za wyświetlanie pól planszy. Litery te znajdują się przed znakami pól planszy, a dokładniej przed znakami "|".
Tak przedstawiają się w skrócie poszczególne zmienne. Przechodząc dalej do opisu działania metody "setPlayersShips()" widzimy pętlę, wywołującą kod dla bieżącego gracza. Warunkiem zatrzymania pętli jest wartość zmiennej "players", wynosząca przynajmniej 2 (inkrementowanej oczywiście pod koniec), co oznacza, zakończenie wybierania statków dla ostatniego gracza. W pętli tej znajdują się odwołania do dwóch zmiennych z zakresu globalnego metody "setPlayersShips()" - "players" i "shipPage", które służą kolejno do przejścia do kolejnej serii ("players") zapytań o położenie statku ("shipPage") oraz do wyzerowania paneli informacyjnych odnośnie ustawiania statków. Następnie w ów pętli znajduje się kolejna pętla, która jest odpowiedzialna za powtarzanie kodu wyznaczania pozycji współrzędnych statku na planszy danego gracza. Kod ten jest powtarzany tyle razy, ile jest statków, czyli 7 dla każdego gracza z pętli nadrzędnej. Na końcu pętli nadrzędnej (graczy) znajduje się zwrócenie tablicy dwuwymiarowej, zawierające współrzędne poszczególnych statków graczy do zmiennej string[,] "playersShipCoorData_AR" metody "activeGameLoop()" klasy "GameLoop".
Początkiem pętli potomnej (pozycjonowanie statków) jest wyświetlenie graficznej tablicy przedstawiającej planszę, na którą ustawiane są statki, aby pokazać graficznie gdzie dokładnie znajdują się. Dane w tablicy są wyświetlane za pomocą pętli "for". Dla każdego przypada jedna plansza która jest wyświetlana względem zmiennej "players", której wartości liczbowe 0 i 1 odpowiadają kolejno graczowi pierwszemu i drugiemu. Za planszą znajdują się panel informacji dotyczący aktualnie ustawianego statku aktywowane za pomocą odpowiednich wartości powyżej podanych odpowiednich zmiennych typu bool. Następnie znajduje się informacja o ustawieniu wszystkich siedmiu statków na planszy. Informacja ta pojawia się tylko wtedy kiedy program przechodzi do początku zapytań i operacji ustawiania statków dla danego gracza. Później następuje ponowne wyświetlenie planszy, wraz z panelem informacyjnym. Można by zrobić to inaczej, ustalając tylko jedno wyświetlenie planszy wraz z panelem informacyjnym. Nie zdecydowano się na wybór tej opcji, gdyż utrudniłaby ona czytelność kodu i jego przejrzystość. Takich powtórzeń kodu w pętli jest trzy, a odpowiadają one trzem następującym po sobie etapom: strona wprowadzająca → wyznaczanie kierunku → wyznaczanie współrzędnej początkowej, po których następuje ponowne działanie pętli na tym samym indeksie pętli ([i]), zablokowanie zapytań o kierunek i współrzędną oraz wyświetlenie zapytania o zapisanie danych. Każde z zapytań ma walidację wprowadzanych danych. Jeżeli wprowadzone dane nie będą poprawne, zmienna odpowiedzialna za inkrementację zmiennej pętli (statków) przyjmie wartość 0, co spowoduje, iż pętla nie przejdzie dalej do następnego statku, a wykona się ponownie wykonując komunikat o niepoprawnych danych. Są tutaj dwie ważne rzeczy. Wywoływanie kodu z pętli nie dotyka zapytań o współrzędne, gdyż są one zależne o wartości zmiennej "isCoor" typu bool. Podobnie jest z "isDir" odpowiadającej za zapytanie odnośnie wyznaczenia kierunku statku. Są to swego rodzaju przełączniki włączające i wyłączające określony kod z obiegu w pętli "while" (dotyczącej statków). W programie tym znajduje się duża ilość przełączników tego typu, gdyż zapotrzebowanie na tego typu funkcje jest duże w całej grze. Pierwszym zapytaniem jest zapytanie o kierunek. Jeżeli gracz poda złą wartość, wyskakuje komunikat o podaniu złej  wartości i pętla jest odtwarzana ponownie. Kod odpowiedzialny za zapytanie zostaje wywołany ponownie. Kiedy gracz pisze poprawną wartość, program zapisuje ją w zmiennej "selectDirection" i do zapytania o wyznaczenie punktu początkowego współrzędnej statku. Wyznaczona współrzędna przechodzi krótki proces walidacji sprawdzający czy wybrana współrzędna ma odpowiednią długość znaków. Jeżeli długość znaków jest odpowiednia, jest transportowana do metody "shipCoorBuildChecker()", klasy "ShipBuildChecker", która tworzy dalsze współrzędne statku na podstawie wyznaczonego kierunku położenia statku, jego długości i wartości współrzędnej początkowej. Tworzone współrzędne statku, jak również współrzędna początkowa przechodzą proces walidacji, który określa czy statek:
    1. Nie wychodzi poza planszę.
    2. Nie nakłada się na inny statek.
Po pomyślnie zakończonych operacjach z metody "shipCoorBuildChecker()" zwracane są trzy zmienne w krotce (C# 7.0), którymi są następująco: współrzędne statku – "shipFullCoor", zmodyfikowana (w metodzie "updateBoardContent()" po ustawieniu danego statku lista pól planszy potrzebna do walidacji współrzędnych nowo tworzonego statku – "fullIndex_AR", zmienna "isDone" określająca pozytywny wynik walidacji za pomocą wartości typu bool. Kolejnym krokiem jest wrzucenie poszczególnych współrzędnych statku do tablicy na współrzędne statków pojedynczego gracza, przemieniając oddzielne wartości współrzędnych w ciąg znaków: {"E4", "F4", "G4"} → {"E4|F4|G4"}, w którym każdą współrzędną rozdziela znak "|". Po określeniu wszystkich danych niezbędnych do ustalenia statku wyskakuje zapytanie pytające się czy dany gracz chce zapisać współrzędne statku. Udzielenie pozytywnej odpowiedzi na to pytanie spowoduje, iż współrzędne zostaną przekazane dalej do metody "updateBoardContent()" klasy "BoardContentMaker", w której dochodzi modyfikacji graficznej tablicy planszy, na której pojawia się nowy statek – "playersBoardContent_AR" oraz do modyfikacji tablicy pól planszy potrzebnej do walidacji współrzędnych nowo tworzonego statku – "fullIndex_AR". Obydwie te tablice są oczywiście zwracane z tej metody w zaktualizowanej formie. Kiedy gracz nie zdecyduje się zapisać danych, pętla odpowiedzialna za zapytania i operacje odnośnie ustawiania statku odtwarzana jest od nowa, przez co gracz musi od nowa wybrać dane potrzebne do ustalenia pozycji statku. Wybierając pierwszą lub drugą opcję zresetowane zostaną wszystkie dane, związane z zapytaniami i operacjami odnośnie ustawiania statku. Na końcu tej metody ("setPlayersShips()") znajduje się instrukcja warunkowa zawierająca dwa komunikaty dla odpowiednich graczy, którzy ustawili swoje statki na swoich planszach, informujące ich o zakończeniu ustawiania ich statków.
Metoda "fight()" klasy "GameProper" odpowiada za wyświetlanie zapytań i przeprowadzanie operacji związanych z logiką bitwy gry. Wywołanie tej metody następuje, gdy gracze ustawią swoje statki. Metoda ta ma jeden parametr, którym jest tablica przechowująca współrzędne statków graczy. Na początku metody "fight()" znajduje się deklaracja głównych zmiennych, które odpowiadają kolejno za przechowywanie współrzędnych statków dla danego gracza w tablicy typu string[,] w formie łańcuchów znaków oraz za przechowywanie informacji o zwycięzcy. Za nimi znajdują się zmienne, które tworzą listę List<List<List<string>>>, zawierającą współrzędne statków graczy. Jej struktura wygląda tak: gracz → statek → zestaw współrzędnych → współrzędna. Dalej znajduje się lista do której wkładane są współrzędne skonwertowane z tablicy typu string[]. Ostatnią zmienną jest lista string[] do której wkładane są przetworzone współrzędne typu "A2", "B2", "C2" z "A2|B2|C2". Na początku działania metody "fight()" po deklaracji zmiennych współrzędne typu "A2|B2|C2" konwertowane są do postaci "A2", "B2", "C2" oraz wkładane do listy List<List<List<string>>>. Użyto tu listy (nie tablicy), gdyż do logiki bitwy potrzebne są współrzędne, z których każda jest oddzielona od siebie i włożona jako poszczególny indeks najbardziej zagnieżdżonej listy należącej do List<List<List<string>>>. W tej części metody "fight()" klasy "GameProper" użyta jest metoda "Split()" obiektu Array" w celu rozdzielenia współrzędnych "A2|B2|C2" na "A2", "B2", "C2" w łańcuchu znaków i władowania ich do zmiennej string[]. Argumentem metody "Split()" jest "|". Pod spodem znajduje się znajduje się kombinacja metod "Select(x => x.ToString()).ToList()", która konwertuje dane z tabeli string[] do listy List<string>, w celu umożliwienia włożenia tej listy do odpowiedniej listy dwuwymiarowej List<List<string>>. Metoda "ToString()" określa typ zmiennych (tutaj string). Na końcu operacji konwersji danych lista List<List<string>> jest wkładana do listy trójwymiarowej List<List<List<.string>>>. Następną operacją w metodzie "fight()" jest utworzenie listy o strukturze odpowiadającej liście przechowującej skonwertowane współrzędne typu "A2", "B2", "C2". W zasadzie jest to jej klon, tylko z tą różnicą, iż zamiast wartości współrzędnych znajdują się tam (na początku) wartości "??". Lista ta jest używana w panelu informacyjnym podczas bitwy, w którym znajdują się wypunktowane współrzędne poszczególnych statków. Kolejną operacją metody "fight()" jest skonwertowanie danych typu "C2" na dane typu liczbowego: "22" i zamianę ich typu zmiennych string na typ int – 22 poprzez wrzucenie ich do nowej listy z tym właśnie typem, używając metody "int.Parse()", aby można było bez problemu użyć ich do logiki strzelania metody "fire()" klasy "ShipCannon". Następnie są deklarowane zmienne potrzebne do przeprowadzania zapytań odnośnie bitwy. Są to:
    1. Zmienne typu bool podobnie jak w metodzie "setPlayersShips()" pełnią one funkcję przełączników, odpowiadających za włączanie i wyłączanie fragmentów kodu z obiegu pętli znajdującej się poniżej tych zmiennych. Odpowiadają one kolejno za:
       "isFight" – działanie pętli.
       "isPlayerChoose" – wybór gracza.
       "isSetBeginPlayer_FirstTime" – włączenie do obiegu wywoływania kodu w pętli bitwy, a dokładniej zapytania o atakowane pole.
       "isReturn" – zatrzymanie się wykonywania programu na tym samym graczu, kiedy poda on niepoprawną współrzędną oraz współrzędną, którą już wcześniej podał.
       "isMiss" – określenie sytuacji w której gracz nie trafił statku wroga po oddanym strzale.
       "isWinner" – określenie zwycięzcy.
    2. int "attackPlayer" zawiera liczbę określającą gracza, który jest atakowany.
    3. int "gamePlayer" zawiera liczbę określającą gracza, który atakuje swojego przeciwnika.
    4. string "playerReadLine" przechowuje wartość, określającą gracza, który zaczyna bitwę jako pierwszy.
    5. Tablica typu string[,,] "playersBoardFight_AR" przechowuje stan plansz obu graczy podczas bitwy. Przyjmuje trzy wartości. Są nimi: początkowy znak "~" dla pól, które nie zostały ostrzeliwane, "X " dla pól na które przeprowadzono ostrzał i uszkodzono statek oraz „O ”, które ostrzelano, ale nie nie trafiono w statek.
    6. Lista List<List<int>> "playersBoardFight_intToSplice_AR" przechowująca współrzędne liczbowe poszczególnych plansz dla danego gracza. Jest ona wykorzystywana do przeprowadzenia poprawnej walidacji w określeniu zgodności ostrzeliwanego pola względem możliwego znajdowania się tam części statku.
Na początku pętli odpowiedzialnej za przeprowadzenie bitwy wyświetlane są plansze współrzędnych obu graczy. Pod nimi wyświetlane są informacje o statkach graczy, zawierające na początku wartości "??". Wartości te znajdują się w trójwymiarowej liście o strukturze: gracz → statek → współrzędne → współrzędna. Dane te wyświetlane są względem graczy, tzn. dla gracza pierwszego są wyświetlane informacje o jego statkach. Tak samo jest w przypadku drugiego gracza. Wszystkie te zestawy danych są wyświetlane przy użyciu jednej pętli „for”. Statki obu graczy są rozdzielane od siebie odstępami odpowiedniej długości, względem długości przestrzeni zajmowanej przez wyświetlenie współrzędnych statków graczy. Przykładowo dla statków o długości 5 współrzędnych odstęp będzie mały, a przy statkach o długości 2 współrzędnych odstęp będzie duży. Decyzja o długości odstępu jest podejmowana w warunku instrukcji „switch”, która w tym przypadku skraca kod w przypadku użycia instrukcji "if/else" oraz przede wszystkim zwiększa czytelność kodu. Następnie znajduje się zapytanie o wybór gracza, który zacznie bitwę. Kiedy gracz zostanie wybrany, fragment kodu odpowiedzialny za to zapytanie i operacje z nim związane jest wyłączany z obiegu pętli. Pętla wykonuje się ponownie. Wówczas włączany jest kod odpowiedzialny za wskazanie planszy wybranego gracza. W kodzie tym włączany jest przełącznik "isSetBeginPlayer_FirstTime", który włącza do obiegu kod odpowiedzialny za przeprowadzenie bitwy. W trakcie bitwy strzelają na przemian do siebie w celu zatopienia wszystkich statków swojego przeciwnika. Jeżeli któryś z graczy trafi któryś ze statków swojego przeciwnika, gracz ten może strzelić ponownie. Ta aktywność powtarza się dopóki gracz ten chybi, nie trafiając w statek swojego wroga. Strzelanie odbywa się poprzez podanie współrzędnej pola planszy przeciwnika, które gracz chce zaatakować. Po podaniu współrzędnej tego pola przechodzi ona pierwszy proces walidacji, gdzie sprawdzane jest czy współrzędna ta nie ma pustej wartości i czy ma odpowiednią długość. Po udanym pierwszym procesie wartość współrzędnej jest konwertowana z typu wartości "C2" na "22" i przechodzi drugi proces walidacji polegający na sprawdzeniu czy wartość ta pole to istnieje na planszy wroga oraz czy współrzędna ta nie została już wcześniej wybrana.. Po pomyślnym wyniku, współrzędna ta wkładana jest to metody "fire()" klasy "ShipCannon", jako jeden z jej siedmiu argumentów, gdzie jest przeprowadzana logika strzelania. Metoda "fire()" zwraca siedem argumentów, niezbędnych do prawidłowego przeprowadzania bitwy. Kiedy któryś z graczy zniszczy wszystkie statki u swojego przeciwnika – następuje koniec bitwy i określenie zwycięzcy. Zwycięzcę określa zwrócona z metody "fire()" zmienna "winner". Zmienna ta jest zwracana z metody "fight()" klasy "GameProper" do klasy nadrzędnej "GameLoop" do zmiennej "winner" , znajdującej się w wywoływanej metodzie "activeGameLoop()". Zmienna ta jest później transportowana do wywołania metody "winnerInfo()" instancji klasy "Prize" utworzonej w  tej metodzie ("activeGameLoop") klasy "GameLoop".

13. Klasa "Prize":
W klasie "Prize" znajduje się tylko jedna metoda o nazwie "winnerInfo()". Metoda ta odpowiada za wyświetlanie informacji o zwycięzcy, oraz za zapytanie czy gracze chcą ponownie zagrać w grę. Metoda ta posiada jeden parametr, którym jest określony wcześniej zwycięzca bitwy. Na początku metody znajduje się deklaracja trzech zmiennych. Są to:
    1. Zmienna "winPlayer" typu string przechowująca parametr tej metody.
    2. Zmienna "wantGameAgain" typu string zawierająca odpowiedź w sprawie ponownej gry.
    3. Zmienna "isChoose" typu bool zawierająca decyzję o ponownej grze. Wartość "true" oznacza wybranie ponownej gry, a "false" przejście do napisów końcowych gry.
Wszystkie operacje metody "winnerInfo()" są dokonywane w pętli "while", która zapętla wywoływanie kodu, do momentu zdecydowania się w sprawie ponownej gry. „wantGameAgain” przyjmuje wartości "yes" i "no" i podlega walidacji. Jeżeli gracz wpisze wartość inną niż "yes" lub "no", pętla powtórzy się i zapytanie o ponowną grę zostanie wyświetlone ponownie. Kiedy gracz zdecyduje się zakończyć grę, pętla jest wyłączana za pomocą zmiany wartości zmiennej typu bool "isChoose" na "false", następuje i przekazanie "wantGameAgain" z wartością "no", przez co następuje przejście wykonywania programu w metodzie „Main” klasy „Program” przestrzeni nazw "OutputProgram". Jeżeli gracz wybierze ponowną grę pętla kończy swoje działanie, a następnie z tej metody ("winnerInfo()") zwracana jest zmienna "wantGameAgain", z wartością odnoszącą się do decyzji o ponownej grze do metody "activeGameLoop" klasy "GameLoop". Zwrócona zmienna jest podstawiana do warunku wywoływania pętli w metodzie "activeGameLoop()", która odpowiada za wywołanie całej gry. Kiedy po zakończeniu gry i działania wszystkich w niej pętli "while" zmienna ta będzie miała wartość "yes", pętla wykona się ponownie, a z nią cały kod odpowiedzialny za grę, w tym ustawianie statków, bitwa i wyświetlenie zwycięzców z zapytaniem o ponowną grę. Kiedy zmienna ta będzie miała wartość „no”, pętla odpowiedzialna za wywoływanie całej gry zakończy swoje działanie i program przejdzie do napisów końcowych.

14. Klasa "BoardContentMaker":
Klasa "BoardContentMaker" składa się z czterech metod, z których metody  "set_fieldAreaContent_AR()", "set_fullIndex_AR()" i "set_dangerFields_AR()" są odpowiedzialne za tworzenie określonej struktury tablic z określonymi wartościami, a część za aktualizację ich wartości według określonych instrukcji. Czwarta metoda "updateBoardContent" jest odpowiedzialna za aktualizację graficznej tablicy plansz graczy i aktualizację tablicy dostępnych pól, potrzebnej do walidacji nowo tworzonych współrzędnych statków. Oto krótki opis powyższych metod:
"fieldAreaContent()" – tworzy graficzną tablicę trójwymiarową typu string[,,] planszy obu graczy o strukturze: gracz → rząd (wiersz) → indeksy (), przechowującą stan plansz graczy. Wartością początkową jest "~ ". Tablica ta jest wykorzystywana w mechanice ustawiania statków, oraz w logice bitwy.
"set_fullIndex_AR()" – tworzy dynamiczną listę, elementów odpowiedzialnych za prawidłową walidację dostępności współrzędnych na planszy danego gracza.
"set_availableFields_AR()" – tworzy listę niedostępnych pól dla statków o określonym kierunku położenie i długości. Na początku tej metody tworzone są listy dwie dwuwymiarowe zawierające niedostępne pola (int) dla danej długości danego kierunku położenia statku. Na tym etapie niedostępne pola odpowiadają jedynie ostatniej cyfrze wartości liczbowej długości, np.: dla długości 3 i kierunku "R" niedostępnymi polami będą {"8", "18", "28", "38", "48", "58", "68", "78", "88", "98"}. Kolejnym etapem tej funkcji jest połączenie wszystkich tablic niedostępnych pól względem długości statków, tak aby np. statek  o długości 3 i kierunku „R” zawierał pola {"8", "9",  "18", "19", "28",  "29",  "38", "39", "48", "49", "58", "59", "68", "69", "78", "79", "88", "89", "98", "99"}, w tym niedostępne pola dal statku o długości 2 i kierunku "R", a nie tylko {"8", "18", "28", "38", "48", "58", "68", "78", "88", "98"} odpowiadające jego długości, czyli 3. Do połączenia list niedostępnych pól ze sobą i zwrócenia ich do nowych list służy metoda "Concat()" doczepiana do każdej kolejnej tablicy, którą trzeba połączyć, wraz z metodą "To.List()" na końcu, która to określa, że z łączenia poszczególnych list ma się utworzyć lista. Na końcu metoda ta wkłada te dwie listy niedozwolonych pól i wsadza je do kolejnej listy. Struktura tej listy wygląda tak: kierunek → długość statku → zestaw niedostępnych pól → niedostępne pola.
"updateBoardContent()" – jest odpowiedzialna za aktualizację graficznej tablicy plansz graczy i aktualizację tablicy dostępnych pól, potrzebnej do walidacji nowo tworzonych współrzędnych statków. Funkcja ta ma zwraca dwie zmienne, którymi są dwuwymiarowa lista "splicedBoard_AR" pełna cyfr od 0 do 99 dla dwóch graczy oraz trójwymiarowa tablica "outputBoardData" przekazująca graficzną tablicę stanu plansz obu graczy. Zmienne te są modyfikowane w tej metodzie i zwracane po ich modyfikacji. Funkcja ta posiada pięć parametrów są to kolejno:
    1. List<List<int>> "fullIndex_AR" – podstawa do walidacji współrzędnych w metodzie "shipCoorBuildChecker()". Tutaj jest ona modyfikowana, aby uniemożliwić układanie się statków na siebie. Zmienna ta jest wkładana do zmiennej utworzonej w tej metodzie "splicedBoard_AR" i po zakończeniu jej modyfikacji wkładana ponownie do tego parametru, znajdującego się poza tą metodą ("updateBoardContent()") .
    2. string[] "shipFullCoor" – tablica zawierająca oddzielone od siebie współrzędne danego statku gracza w postaci {"A2", "B2", "C2"}.
    3. string[,,] "playersBoardContent_AR" – tablica przechowująca graficzną zawartość plansz obu gracz, która jest modyfikowana w tej metodzie ("updateBoardContent()").
    4. int „players” – liczba od 0 do 1 reprezentująca gracza.
    5. int "shipPage" – liczba od 0 do 6 oznaczający dany statek, która wykorzystywana jest jako wartość wypełnienia określonych pól z tablicy "playersBoardContent_AR", kiedy gracz ustawi tam statek. Przykładowo, jeżeli gracz ustawił czwarty statek o długości 3 na polach "A2", "B2", "C2", to na tych polach w tablicy "playersBoardContent_AR" na jej indeksach [player, 0, 2], [player, 1, 2], [player, 2, 2], (player – 0 lub 1, w zależności od gracza) jest wstawiany znak "4", który odnosi się do czwartego statku. Warto dodać, iż zmienna "shipPage" jest inkrementowana o 1 przed modyfikacją tablicy string[,,].
Trzeba teraz zwrócić tu uwagę na jedną rzecz. Metoda „” nie zwraca zmodyfikowanej listy, która zawierałaby modyfikowany na bieżąco zbiór współrzędnych statków dla każdego z graczy. Za operację tą jest metoda "setPlayersShips()" klasy "GameProper", która na podstawie wyniku walidacji współrzędnych w metodzie "shipCoorBuildChecker()" klasy "ShipBuildChecker" określa czy współrzędne te są dostępne w tablicy pól na danej planszy.
Wracając do metody "updateBoardContent", na początku jej działania następuje konwersja konwersja ich wartości współrzędnych typu "B2" na "12". Następnie uzyskane wyniki są rozdzielane na dwa elementy. W przypadku „12” będzie to 1 i 2. Kolejną operacją jest zamiana ich na typ int oraz podłożenie kolejno do indeksów tablicy "outputBoardData", w następujące miejsca, w przypadku 1 i 2 będzie to: [player, 1, 2]. Do lokacji w tej tablicy wkładana jest wówczas wartość numeru statku. Zwrócona później tablica "outputBoardData" i wyświetlona w oknie konsoli pokaże ustawienie statku na planszy danego gracza. Po serii tych operacji następuje kolejna, ale mniejsza. Dotyczy ona skracania listy "splicedBoard_AR". Lista "splicedBoard_AR" zawiera wartości od 0 do 99 które reprezentują pola wszystkich dwóch plansz. Lista ta pełni kluczową rolę podczas walidacji współrzędnych, ponieważ określa które pola są dostępne na danej planszy. Kiedy przykładowo plansza pierwsza jest pusta, i ustawiony został na nie statek, to następuje wówczas usunięcie w liście  "splicedBoard_AR" indeksów, które swoją wartością odpowiadają wartością współrzędnych, skonwertowanych do liczby, np. "22", skonwertowanym z „C2”. Gdy  "splicedBoard_AR[22]" jest równy skonwertowanej "C2", czyli 22, to następuje wówczas usunięcie tego indeksu listy "splicedBoard_AR", dzięki czemu tablica ta odpowiada rzeczywistemu układowi pól na planszy który jest aktualnie dostępny. Do przeprowadzenia tej operacji używane są metody "IndexOf()" i "RemoveRange()". Pierwsza z nich na podstawie wartości danego indeksu listy "splicedBoard_AR" określa który indeks ma zostać z niej usunięty, a druga usuwa ten indeks, powodując zapadnięcie się indeksów następujących po nich w kierunku indeksu [0]. Przykładowo, jeżeli jest lista z wartościami {1, 2, 3, 4, 5} i usunie się indeks o wartości 3, to zawartość listy będzie wyglądała tak: {1, 2, 4, 5}. Wówczas kiedy w tej liście będzie chciało się znaleźć indeks o wartości 3, nie znajdzie się go, gdyż nie istnieje taki indeks, który ma wartość 3. Na tym sposobie obiera się część logiki walidacji ustawiania statków i logika strzelania. Warto opisać tu szerzej metodę "IndexOf()". Można mieć listę o 1000 indeksów pomieszanymi wartościami od 0 do 999 na przestrzeni wszystkich indeksów. Aby usunąć ręcznie indeks o wartości 348, trzeba by jej szukać. Metoda "IndexOf()" zaoszczędza masę pracy, gdyż znajduje za na indeks z tą właśnie wartością. Na końcu metody "updateBoardContent()" zwracane są zmienne "outputBoardData" i "splicedBoard_AR".

15. Klasa "ShipBuildChecker":
Klasa ta zawiera jedną metodę, która nazywa się "shipCoorBuildChecker()". Metoda ta służy do tworzenia dalszych współrzędnych statku, w zależności od jego kierunku położenia, które składają się na jego długość całkowitą oraz do sprawdzania czy te nowo utworzone współrzędne są dostępne w liście List<List<int>> dostępnych pól "fullIndexArray" danej planszy, które pełnią kluczową rolę w prawidłowym umieszczaniu statków na planszy i ich walidacji. Metoda ta posiada siedem parametrów. Są to:
    1. string "firstCor" – współrzędna początkowa.
    2. string "direction" – kierunek statku.
    3. string "length" – długość statku.
    4. List<List<List<int>>> "dangerFields" – lista niedostępnych pól dla wszystkich kierunków położenia statków wszystkich długości.
    5. List<List<int>> "fullIndexArray" – lista dostępnych pól obu plansz.
    6. int "players" – liczba od 0 do 1 reprezentująca gracza.
    7. bool "isDone" – informacja o dostępności współrzędnych statku na planszy.
Pierwszą operacją metod "shipCoorBuildChecker()" jest konwersja wartości danych z postaci „B2” na postać „12”. Następnie są wybierane niedozwolone pola z listy współrzędnych z względem i kierunku i długości statku, aby uniemożliwić położenie go w lokacji, w której wychodziłby poza planszę. Kolejnym etapem jest sprawdzanie czy statek nie wyjdzie poza planszę na podstawie lokalizacji współrzędnej początkowej, względem jego długości i kierunku położenia. Jeżeli współrzędna początkowa znajduje się na którymś polu z listy niedozwolonych pól, metoda kończy swoje działanie w tym momencie i zwracany jest komunikat o wychodzeniu statku poza planszę. Jeśli sprawdzian ten zakończy się powodzeniem, program przechodzi do wykonywania dalszej części metody, którą jest sprawdzenie czy współrzędna początkowa znajduje się w liście dostępnych pól "fullIndex_AR". Lista "fullIndex_AR" zawiera wartości od 0 do 99 które reprezentują pola wszystkich dwóch plansz. Lista ta pełni kluczową rolę podczas walidacji współrzędnych, ponieważ określa które pola są dostępne na danej planszy. "fullIndex_AR" ma kasowane indeksy w metodzie "updateBoardContent()" klasy "ShipBuildChecker", kiedy jest ustawiany statek na planszy. Ma to zapobiec nakładaniu się statków na siebie. Przykładowo w liście "fullIndex" nie ma indeksów z wartościami 22 i 32, które odpowiadają współrzędnym "C2" i "D2". Kiedy gracze zdecyduje się umieścić statek, którego współrzędna początkowa będzie znajdowała się na "C2", czyli 22, zostanie wykryta równość, która w tym kontekście oznacza nakładanie się na siebie statków. Zostanie wówczas wyświetlony komunikat o nakładaniu się statków. Jeżeli współrzędna początkowa będzie istniała w liście dostępnych pól, program przejdzie do kolejnej operacji. Operacją tą jest tworzenie dalszych współrzędnych statku, które są określane za pomocą jego kierunku położenia i długości. Po utworzeniu tych współrzędnych, przechodzą one dokładnie taki sam proces walidacji jaki przeszła współrzędna początkowa, ale proces ten dotyczy tylko sprawdzenia nienakładania się statków, gdyż wcześniej określono już czy statek będzie wychodził poza planszę. Pod koniec funkcji "shipCoorBuildChecker()" współrzędne liczbowe statku są konwertowane na postać typu "B4" i wkładane do tablicy "result". Na końcu zwracane są zmienne "result", "fullIndex_AR", "isResult".

16. Klasa "ShipCannon":
Klasa ta zawiera jedną metodę, o nazwie "fire()". Funkcja ta posiada siedem parametrów. Oto ich krótki opis:
    1. List<List<List<int>>> "playersShips_int_AR" – lista zawierająca współrzędne  statków wszystkich graczy o wartościach typu 44.
    2. List<List<List<string>>> "playersShips_string_AR" – lista zawierająca współrzędne  statków wszystkich graczy o wartościach typu "E4".
    3. List<List<List<string>>> "playersShips_unknown_AR" – lista zawierająca współrzędne  statków wszystkich graczy o wartościach równych "??".
    4. string[,,] "playersBoardFight_AR" – tablica zawierająca graficzny stan planszy obu graczy.
    5. List<List<int>> "playersBoardFight_intToSplice_AR" – dwuwymiarowa lista indeksów od 0 do 99 dla obu graczy, z która jest skracana równomiernie w stosunku do statków znajdujących się na planszach graczy.
    6. int "fireCoorConv" – atakowane pole planszy.
    7. int "player" – liczba od 0 do 1 reprezentująca gracza.
Metoda ta zwraca siedem zmiennych. Oto ich krótki opis:
    1. List<List<List<int>>> "playerShips_Coor_AR" – lista zawierająca współrzędne statków wszystkich graczy.
    2. List<List<List<string>>> "unknownSign_AR" – lista zawierająca zmodyfikowane dane typu "??".
    3. string[,,] "playersBoard_Fight_AR" – tablica zawierająca zmodyfikowany graficzny stan planszy obu graczy.
    4. List<List<int>> "playerBoardFight_toSplice_AR" – dwuwymiarowa lista indeksów od 0 do 99 dla obu graczy, z która jest skracana równomiernie w stosunku do statków znajdujących się na planszach graczy.
    5. bool "isMiss" – określenie sytuacji w której gracz nie trafił statku wroga po oddanym strzale.
    6. bool "isWinner" – zmienna typu bool określająca, koniec gry, a dokładniej sytuację w której jeden z graczy wygrał bitwę.
    7. string "winner" – łańcuch znaków reprezentujący zwycięzcę.
Działanie metody "fire()" opiera się na pewnej idei. Do metody tej przekazywane są współrzędne statków wszystkich graczy. Znajdują się one w liście trójwymiarowej o strukturze: gracz → statek → zestaw współrzędnych → współrzędna. Na początku program sprawdza, czy ostrzeliwana współrzędna znajduje się w tej liście. Następnie program na podstawie wystąpienia trafienia (współrzędna znajduje się w liście) określana czy gracz chybił. Kolejną operacją jest aktualizacja zawartości tablicy graficznego stanu planszy danego gracza. Jeżeli ostrzeliwana współrzędna istnieje w powyższej liście, to do tablicy graficznego stanu planszy wstawiany jest w odpowiednie miejsce ciąg znaków "X ", oznaczający trafienie. W przeciwnym razie wstawiany jest ciąg znaków "O ", oznaczający nie trafienie w statek. Odstęp " " jest po to, aby dane na planszy nie ściskały się, poprawiając czytelność planszy. Niezależnie od wyniku sprawdzianu, z listy "playerBoardFight_toSplice_AR" usuwany jest indeks odpowiadający tej współrzędnej, np. jeżeli współrzędna wynosiła: G6, to usuwany jest indeks 76 (po konwersji "G6" na 76 ("A4" = 4, "C7" = 27), w celu wyłączenia dostępu do tego pola, gdyż zostało ono ostrzelane. Usuwanie to ma miejsce przed zaktualizowaniem tablic graficznego stanu plansz. Następnie program usuwa z listy "playerShips_Coor_AR" skonwertowana na liczbę wartość ostrzeliwanego pola. Kolejną operacją jest pobranie długości poszczególnych statków danego gracza listy "playersShips_int_AR". Po tej operacji następuje sprawdzenie które statki mają zerową długość. Jeżeli któryś ze statków ma zerową długość, znaczy to, że został zatopiony. Wówczas w bitwie na panelu informacyjnym, wyświetlającym zamaskowane współrzędne obu graczy ("??") pojawiają się współrzędne tego statku (dla określonego gracza). Jeżeli dla danego gracza długość wszystkich statków wynosi 0, oznacza to, iż jego przeciwnik wygrał bitwę. W tym momencie pętla razem z bitwą kończy swoje działanie.

17. Klasa "GameCredits":
Klasa "GameCredits" zawiera tylko jedną metodę. Jest nią "showCredits()", która wyświetla napis "GAME CREDITS", składający się ze znaków "B", a za nim podziękowanie za grę, wraz z informacją o autorze gry. Na dole znajduje się komunikat, informujący o końcu programu, który nastąpi, jeśli zostanie naciśnięty klawisz "Enter".

18. Testy:
Program ten był wielokrotnie testowany na różnych etapach produkcji. Celem testów było sprawdzenie poprawności działania programu i znalezienie wszystkich możliwych do wystąpienia błędów, z zamiarem likwidacji ich. W celu osiągnięcia jak największej wydajności pracy oraz związanego z tym zminimalizowania występowania błędów, program był często poddawany testom jednostkowym, poszczególnych części metod danych klas i finalnie przy testowaniu działania całych metod oraz zwracania z nich przetworzonych (w nich) zmiennych do innych metod tej samej klasy. Testy były przeprowadzane  niemal co 20 linii kodu, więc nie ma sensu opisywać co zostało przetestowane, jak przebiegał ten test, jakie były jego założenia. Ważniejszym punktem jest sposób, a dokładniej idea przeprowadzania tych testów. 
Wszystkie testy były przeprowadzane na podstawie wyświetlania w konsoli określonych danych, na podstawie których było stwierdzane, czy program działa poprawnie, oczywiście we wszystkich możliwych przypadkach wystąpienia tych danych. Dane były przekazywane w dwóch formach. Pierwszą z  nich był zwykły komunikat "Console.WrieLine()" z określoną w środku wartością, poprzedzany oczywiście wykasowaniem zawartości okna konsoli za pomocą "Console.Clear()" oraz znajdującym się na końcu komunikatem o kontynuowaniu gry z "Console.ReadLine()". Drugą formą testów było wyświetlanie danych z danej tabeli za pomocą pętli „for” (w tym także zagnieżdżonych) w celu sprawdzenia ich poprawności względem oczekiwanych wyników. Linie kodu odpowiedzialne za testy zostały usunięte, z powodu przejścia przez program wszystkich testów oraz w celu zwiększenia czytelności kodu.

19. Bibliografia:
Do utworzenia programu wykorzystano wiedzę z następujących źródeł:
C# 9.0 Leksykon Kieszonkowy – Joseph Albahari, Ben Albahari
C# Praktyczny kurs – Marcin Lis (wydanie 3)
