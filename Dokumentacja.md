Dokumentacja

1. Opis ogólny projektu:
Projekt jest grą konsolową o nazwie Battleship. Battleship to strategiczno-planszowa gra dla dwóch osób. Każdy z graczy posiada po dwie plansze o wielkości, 10x10 pól. Pola oznaczone są poprzez współrzędne literami od "A" do "J" i liczbami "0" do "9". Każdy gracz ustawia swoje statki na planszy. Po ustawieniu statków zaczyna się bitwa, którą wygrywa ten gracz, który zatopi wszystkie statki swojego przeciwnika. Na drugim zaznacza trafione statki przeciwnika i oddane przez siebie strzały. Statki ustawiane są w pionie lub poziomie, w taki sposób, aby nie wychodziły poza planszę oraz nie nakładały się na siebie. Łącznie jest 7 statków o różnej długości. Długość zaczyna się od 2 pól, a kończy na 5 polach. Trafienie okrętu przeciwnika polega na strzale, który jest odgadnięciem położenia jakiegoś statku. Strzały oddawane są naprzemiennie, poprzez podanie współrzędnych pola (np. "B5"). Zatopienie statku ma miejsce wówczas, gdy gracz odgadnie położenie całego statku. O chybieniu informuje gracza znak "O" pojawiający się na polu, które ostrzeliwał. Trafienie jest oznaczane znakiem "X". Wygrywa ten, kto pierwszy zatopi wszystkie statki przeciwnika. 
Gra nieco różni się od oryginału, czego przejawem jest regulacja niektórych zasad. Zabieg ten ma na celu zwiększenie elastyczności i efektywności rozgrywki oraz stanowi swego rodzaju oryginalny pomysł na rozgrywkę.

2. Cele projektu:
Głównym celem projektu jest przede wszystkim wzbudzenie ciekawości i zachwytu u osób rozpoczynających naukę programowania, bądź osób, które planują ów naukę oraz zaprezentowanie im możliwości języka C# wykorzystując do tego podstawową znajomość składni ów języka, w tym: właściwości, metod i klas. Bardzo często, jak nie zawsze programy konsolowe i ich tworzenie wprawia nowicjuszy programowania w osłupienie i agonię, związane z zetknięciem się z nigdy dotąd nieznanym środowiskiem programistycznym oraz językiem programowania, którego działania ci nowicjusze nie rozumią w znacznej części, bądź wcale. Sposób działania gry, jak również jej funkcje mają zachęcić tych ludzi do podjęcia solidnej i wytężonej nauki programowania oraz wzmożyć w nich chęć trwania w tejże nauce. Pomijając główny cel, projekt ten stanowi także źródło rozrywki i relaksu przeznaczone dla dwójki osób.

3. Informacje o autorze:
Autorem programu jest: Patryk Szewczyk - uczeń Akademii Handlowej Nauk Stosowanych 1 semestru na kierunku: Informatyka. Autor zakazuje kopiowania i udostępniania gry, korzystania z niej w celach marketingowych i sprzedawania jej jako samodzielnego produktu.

4. Struktura programu:
Cały program jest napisany w oparciu o programowanie obiektowe. Program składa się z dwóch przestrzeni nazw odpowiedzialnych za dołączenie do programu odpowiednich bibliotek oraz dwóch przestrzeni nazw zawierających na kod programu: "OutputProgram" i "InputWorkProgram". W przestrzeni "OutputProgram" znajduje się główna klasa programu "Program" ze swoją główną metodą "Main(string[] arg)", która wywołuje proceduralnie kod, w którym znajdują się polecenia dotyczące tworzenia instancji klas z przestrzeni "InputWorkProgram", która pełni funkcję przestrzeni wykonawczej. Przestrzeń wykonawcza jest przestrzenią, w której wykonywane są wszystkie operacje odnośnie gry. W grze wielokrotnie jest użyta pętla while, która pełni funkcję ponownego wykonania danego bloku kodu, dzięki czemu możliwe jest wykonanie takich operacji jak ponowne ułożenie statku, jeżeli źle go ułożyliśmym, jak również umożliwia ponowną grę po zakończeniu bieżącej.

5. Działanie programu:
Działanie programu rozpoczyna się i kończy tylko i wyłącznie w metodzie "Main()" klasy "Program", wyjściowej przestrzeni nazw "OutputProgram". Lecąc od samej góry tworzymy instancje poszczególnych klas z wykonawczej przestrzeni nazw "InputWorkProgram". Kiedy wywołamy metodę danej instancji, przechodzimy do danej metody danej klady wykonawczej przestrzeni nazw. W wykonawczej przestrzeni nazw w celu uporządkowania kodu użyto dziedziczenia do wskazania które klasy są nadrzędna, a które potomne. Mapa dziedziczenia klas przedstawia się następująco:
Program ------ Game Intro,
                        GameLoop, ------ GameProper, ------ BoardContentMaker,
                        GameCredits        Prize                       ShipBuildChecker,
                                                                                    ShipCannon 
W praktyce dziedziczenie nie jest w ogóle potrzebne, ale tak jak napisano powyżej ma ono zasadnicze znaczenie w porządkowaniu klas. 
Kod programu jest kompilowany i wywoływany od góry do dołu tylko i wyłącznie w klasie Program, a jako że znajdują się w niej polecenia dotyczące utworzenia instancji trzech klas potomnych i wywołania ich metod, program zatrzyma się na instancji GameLoop, aby utworzyć wszystkie instancje klas potomnych z klasy "GameLoop", wykona ich metody i dopiero ruszy dalej do utworzenia instancji klasy GameCredits. Reasumując, patrząc na mapę widać, że zanim program dotrze do utworzenia instancji klasy "GameCredits" i wywołania jej metody, utworzy wszystkie instancje klas potomnych klasy "GameLoop".
Szczególną uwagę trzeba zwrócić na klasę "GameLoop" która jest jedną wielką pętlą, umożliwiającą na ponowną grę, kiedy gracze zdecydują się ponownie zagrać, po uprzednio zakończonej sesji. W klasach potomnych tejże klasy ("GameProper", "Prize") mamy do czynienia z kolejnymi pętlami, a w "GameProper" aż z kilkoma zagnieżdżonymi, dzięki którym przy małym nakładzie kodu można wyznaczyć statki dla dwóch grach, zresetować współrzędne danego statku, jak również całą grę, w celu ponownego zagrania w nią.

6. Technologie i Biblioteki:
Program został napisany w całości w języku programowania C# bez użycia frameworków. W programie znajdują się dwie przestrzenie nazw odpowiedzialnych za dołączanie określonych bibliotek. Są to kolejno: System i System.Collections.Generic.
"System" - zawiera podstawowe typy i klasy, takie jak "Console", czy "String".
"System.Collections.Generic" - oferuje generyczne kolekcje, takie jak "List".

6. Szczegółowy opis zawartości przestrzeni nazw "OutputProgram":
Przestrzeń nazw "OutputProgram" jak to zostało wcześniej napisane posiada tylko jedną klasę i metodę, która wykonuje proceduralnie następujące linie kodu. W "OutputProgram" tworzy się instancje klas z przestrzeni nazw "InputWorkProgram", które pełnią swego rodzaju funkcję poszczególnych komponentów tego programu. Komponenty te można wywołać w dowolnej kolejności z tym samym efektem, co w ustalonej w programie kolejności. Dzieje się tak z tego względu, iż pomiędzy metodami instancji klas przestrzeni nazw "InputWorkProgram" nie ma żadnego przekazywania zwracanych wartości.
W metodzie "Main" klasy "Program" przestrzeni nazw "OutputProgram" są tworzone trzy instancje poszczególnych klas: "GameIntro", "GameLoop" i "GameCredits". Klasy te znajdują się w wykonawczej przestrzni nazw "InputWorkProgram".
Klasa "GameIntro" "intro()" odpowiada za wyświetlenie wprowadzenia do gry, w którym znajdują się kolejno: tytuł gry, licencja, informacja o grze, prośba o maksymalizację okna konsoli i komunikat o przejściu dalej. Komunikatów o przejściu dalej jest cała masa. Aby przejść dalej należy kliknąć przycisk "Enter". Metoda "insruction()", odpowiada za wyświetlenie instrukcji gry, wraz z komunikatem o przejściu dalej.
Klasa "GameLoop" odpowiada za wywoływanie "właściwego" kodu gry w pętli, dopóki gracze po zakończonej rozgrywce zdecydują się zakończyć grę. Szczegóły odnośnie tej klasy i jej klas potomnych będą omówione dalej.
Klasa "GameCredits" wyświetla informacje o zakończeniu gry, w tym podziękowania, informacje o autorze i komunikat o zakończeniu programu po kliknięciu klawisza "Enter".

7. Klasy przestrzeni nazw "InputWorkProgram":
W "InputWorkProgram" realizowane są wszystkie operacje związane z grą. Działanie programu w tej przestrzeni opiera się na tworzeniu danych instancji klas i wywoływaniu ich metod. Tak przedstawia się plan klas i kierunek wywoływania kodu odnośnie klas:
Game Intro,
GameLoop, ------ GameProper, ------ BoardContentMaker,
GameCredits        Prize                       ShipBuildChecker,
                                                            ShipCannon 
Zaczynając od samej góry program tworzy instancję klasy "GameIntro" i wywołuje jej metody. Następnie idzie do klasy "GameLoop" i robi dokładnie to samo, z tą różnicą, iż tworzy w niej instancje klas "GameProper" i Prize, gdzie wywołuje także ich metody. Po wywołaniu ich metod program przechodzi do "GameCredits", gdzie kończy się gra. W "GameProper" dzieje się to samo co w "GameLoop" - program tworzy instancje klas potomnych "BoardContentMaker", "ShipBuildChecker" i "ShipCannon" klasy nadrzędnej "GameProper".
Poniżej znajduje się szczegółowy opis wszystkich klas i ich metod z przestrzeni nazw "InputWorkProgram" w kolejności wykonywania programu.

8. Klasa "GameIntro":
"GameIntro" odpowiada za wyświetlenie wprowadzenie do gry oraz instrukcji obsługi gry. Klasa ta ma dwie metody, którymi są "intro()" i "instruction()".
Metoda "intro()" wyświetla na samej górze tytuł gry, który jest napisany w znakach "B". Dalej wyświetla tytuł gry pisany "normalnie" oraz informacje o prawach autorskich. Następnie ukazuje krótki opis gry, wyjaśniający na czy ona polega. Następnie ostrzega użytkownika o błędach, które pojawią się, gdy ten nie zmaksymalizuje swojego ekranu konsoli, w celu pełnego kasowania jej zawartości. Na końcu tej metody znajduje się komunikat, który informuje gracza, że aby przejść dalej trzeba nacisnąć klawisz "Enter". Takich komunikatów jest bardzo dużo w programie, gdyż odpowiadają one za uniemożliwienie niekontrolowanego przejścia dalej, aby np. gracz nie został przeniesiony automatycznie dalej, czego skutkiem byłoby nie dostrzeżenie przez niego przykładowo instrukcji obsługi gry, gdyż zmiana strony nastąpiłaby w zbyt krótkim odstępie czasu, aby gracz mógł wychwycić stronę z instrukcją.
Metoda "instruction()" powoduje wyświetlenie się napisu "INSTRUCTION" składającego się ze znaków "B" i 17 punktów, które mówią o zasadach gry. Na końcu tak jak przy każdej stronie, bądź przy danym etapie pojawia się komunikat o przejściu dalej - tutaj o przejściu do pozycjonowania statków na planszach graczy.

9. Klasa "GameLoop":
W klasie "GameLoop" znajduje się jedna metoda o nazwie "activeGameLoop()". Służy ona do włączania wywoływania gry w pętli, dopóki gracze zdecydują się ją zakończyć w metodzie "winnerInfo()" klasy "Prize". 
Na początku instrukcji pętli program tworzy instancję klasy "GameProper", a następnie wywołuje jej pierwszą metodę – "setPlayerShips()". Metoda ta jest odpowiedzialna za wywołanie wszystkich niezbędnych zapytań oraz operacji z nimi związanych, które mają na celu pobranie od graczy informacji niezbędnych do ustawienia poszczególnych statków. Metoda ta zwraca tablicę trójwymiarową współrzędnych poszczególnych statków obu graczy do klasy "GameProper", a dokładniej do zmiennej "playerShipCoorData_AR", która jest przekazywana jako argument kolejnej metody tej instancji "GameProper") o nazwie „fire()”. Metoda „fire()” odpowiada za przeprowadzenie bitwy pomiędzy dwoma graczami. Dzięki przekazaniu trójwymiarowej tablicy współrzędnych program może na ich podstawie wykonać logikę strzelania gry według ustalonych dla niej instrukcji, w tejże metodzie. Po zakończeniu bitwy „fire()” zwraca informację o zwycięzcy gry do klasy "GameProper" do zmiennej "winner". Pętli gry utworzona zostaje instancja klasy "Prize", a następnie zostaje wywołana jej metoda "winnerInfo()" do której jest przekazywana zmienna "winner", zawierająca informację o zwycięzcy. Metoda "winnerInfo()" wyświetla określony tytułowy komunikat o wygranej (złożony z liter "B"), w zależności od wartości parametru tej metody, czyli informacji o graczu.

10. Klasa "GameProper":
Klasa "GameProper" zawiera dwie klasy: "setPlayersShips()" i "fight()". Obie te metody zwracają po jednej zmiennej do klasy nadrzędnej "GameLoop", do określonych w niej zmiennych, o których była już mowa.
Metoda "setPlayersShips()" odpowiada za wszystkie zapytania i operacje dotyczące określania pozycji statków przez graczy oraz przekazywania tych informacji do metody "ShipBuildChecker" instancji "shipCoorBuildChecker", w celu walidacji danych (współrzędnych), i dodawania ich na bieżąco do tablicy współrzędnych statków graczy jako zbite łańcuchy znaków, a następnie do metody "updateBoardContent" klasy "BoardContentMaker" w celu aktualizacji planszy graczy i tablicy współrzędnych statków graczy.
Działanie metody "setPlayersShips()", jak również sąsiedniej o nazwie fire()  i innych, które są wywoływane przez główną pętlę (w metodzie activeGameLoop() z klasy GameLoop) jest bardzo skomplikowane, przez co na dokładne opisanie ich we wszystkich szczegółach trzeba byłoby poświęcić kilkadziesiąt stron dokumentacji. W związku z tym faktem przyjęto twierdzenie, iż czytelnik posiada znajomość przynajmniej jednego języka programowania, w stopniu, w którym może on swobodnie z niego korzystać do programowania różnych rzeczy w umiarkowanym stopniu trudności.
Na początku metody "setPlayersShips()" mamy deklarację zmiennych, z których trzy są tworzone w oparciu o wywołanie odpowiedniej metody z instancji "BoardContentMaker()". Zmiennymi są następująco: 
    1. Tablica string[,] „playersShipCoor” – która przechowuje współrzędne poszczególnych statków wszystkich graczy. Użyto tu typu tablicy dwuwymiarowej string[,], gdyż, w przeciwieństwie do List<List<string> można swobodnie wrzucać poszczególne wartości do jej indeksów. Struktura danych tej tablicy wygląda następująco: gracz → współrzędne statku. Współrzędne statku są łańcuchem znaków (typ string) takim jak: „A2|B2|C2”. Znaki „|” w ów łańcuchach znaków są użyte jako specjalny rodzaj identyfikatorów, które wykrywane w metodzie fire(), służą do rozdzielania poszczególnych wartości indeksów tablicy trójwymiarowej do której wkładane są te współrzędne, aby były oddzielone od siebie, w celu umożliwienia przeprowadzenia na nich logiki strzelania. Można by przecież od razu włożyć współrzędne statków do tablicy trójwymiarowej, ale oznaczałoby to jeden zasadniczy problem. Ogólnie w logice strzelania i „tworzenia” statków wykorzystuje się skonwertowane współrzędne, które z formy „B2” i „D7” przybierają formę „12” i „37”. Włożenie współrzędnych od razu do tablicy trójwymiarowej oznaczałoby potrzebę ponownego ich wyjęcia w celu konwersji danych na numeryczny rodzaj wartości. Z drugiej strony włożenie danych od razu z konwersją spowodowałoby, iż na panelu informacji o położeniu danego statku, jak również podczas bitwy gracze widzieliby współrzędne statków wyrażone w cyfrach, a nie w postaci „A2 | B2”, czy „E4 | E5 | E6”. Można by od razu zrobić odpowiednie konwersje na wszystkie rodzaje wartości w metodzie „playersShipCoor”, albo wcześniej w „shipCoorBuildChecker” klasy „ShipBuildChecker” i zwrócić wszystkie te tablice w do klasy „GameProper”. Takie rozwiązanie wprowadziłoby zamęt i dezorientacje w zwracaniu zmiennych i nie byłoby zgodne z ideą operacji metody, więc zostawiono dane „D2 | D3” w postaci nienaruszonej.
    2. Tablica string[,,] „playersBoardContent_AR”, zawierająca graficzny układ planszy dla obu graczy, wykorzystywany w tej metodzie do pokazywania położenie aktualnie ustawionych statków. Jej struktura przedstawia się tak: plansza → rząd (wiersz) → indeks rzędu. Pierwszy wymiar „2” oznacza planszę przypadającą na danego gracza. Dwa pozostałe odpowiadają za wymiary planszy 10 x 10. Wartością początkową dla każdego indeksu tablicy „playersBoardContent” jest „~”.
    3. Dwuwymiarowa tablica dynamiczna List<List<int>> „fullIndex_AR” przechowuje tablicę wartości liczb całkowitych od 0 do 99 dla dwóch graczy, które odpowiadają wszystkim indeksom z tablicy graficznej obu plansz. Użyto tu tylu „List”, gdyż oferuje on możliwość dynamicznego zmieniania liczby indeksów tablicy, co w przypadku typu tablicy [,] jest niemożliwe. Istnieje wprawdzie sposób na obejście tego problemu, w postaci tworzenia nowej tablicy z odpowiednią liczbą indeksów z odpowiednimi wartościami, lecz jest on bardzo rudny do zaaplikowania. Zmiana struktury tablicy jest potrzebna do mechaniki ustawiania statków i strzelania do nich.
    4. Trójwymiarowa tablica List<List<List<int>>> „availableFields_AR” przechowuje wszystkie niedozwolone pola na ustawianie statków względem ich długości. Ustawienie statków polega na wyznaczeniu kierunku tworzenia statku – w dół i na prawo oraz współrzędnej początkowej, od której jest tworzony statek za pomocą metody „shipCoorBuildChecker” z klasy „ShipBuildChecker”. W metodzie tej znajdują się walidacje współrzędnych. Jedna z nich dotyczy nie wychodzenia poza planszę. Kiedy tworząc statek o długości dwóch w dół podałoby się „J7”, to logicznie rzecz biorąc statek ten miałby współrzędne „J7 | K7”. Jako że dziesiątą literą od „A” jest „J”, statek wyszedłby poza planszę, co spowodowałoby niemiłe zaskoczenie. W celu uniknięcia takiej sytuacji przeprowadzana jest walidacja wszystkich współrzędnych wykorzystując w tym celu pola niedozwolone dla statku o danym kierunku położenia i długości. Struktura tablicy wygląda następująco: kierunek → długość → zestaw niedostępnych pól
    5. Zmienna „players” typu int przechowująca liczbę odpowiadającą danemu graczowi, która go identyfikuje w metodach w których są używane tablice, zawierające wartości dla obu graczy. Wartość dla gracza pierwszego wynosi 0, a dla drugiego 1.
    6. Zmienna „shipPage” typu int jest podobna do „players”, z tą różnicą, iż odpowiada ona statkom poszczególnych graczy. Zostaną ustawione wszystkie statki dla danego gracza, wartość zmiennej „shipPage” jest resetowana i wynosi 0.
    7. Zmienna „shipPageIncrement” typu int inkrementuje zmienną „shipPage”, kiedy zostaną zakończone wszystkie operacje dla ustawiania danego statku. Zmienna ta na początku jest nieaktywna, tzn. ma wartość 0. Spowodowane jest to tym, iż kiedy zakończy się dana operacja, np. wyznaczania kierunku statku, pętla wykonuje się od nowa w celu aktualizacji informacji o kierunku statku w ogólnej informacji o statku w części gry odpowiedzialnej za ustawianie statków. Kiedy jej wartość wzrasta o 1 wszystkie zapytania o położenie dotyczą następnego statku.
    8. Tablica string[] „shipTypeName_AR” przechowuje tekstowe typy statków. Każdy kolejny typ to jeden statek.
    9. Tablica string[] „shipLengthName_AR” przechowuje długość statków. Jeden indeks tej tablicy przypada na jeden statek. Długość statku jest liczbą pól planszy przypadającą na pole statku. Przykładowo, jeżeli długość wynosi 4, to statek będzie zajmował cztery współrzędne na planszy.
    10. Zmienna „selectDirection” typu string przechowuje kierunek statku, który określa jak przebiega tworzenie statku. Zmienna ta przyjmuje dwie wartości – „B” i „R”. „B” to skrót z angielskiego, oznaczający „bottom”, czyli dół. „” o wartości „B” oznacza, że statki są tworzone do dołu od miejsca wyznaczenia punktu współrzędnej początkowej, która to określa pole na planszy, od którego ma być umieszczony statek. Przykładowo Kiedy wyznaczymy „A2” dla statku o długości 3, dostaniemy współrzędne „A2|B2|C2”. W przypadku wartości „R” („right” - prawo) zmiennej „selectDirection” statek umieszczany jest w kierunku prawym od wyznaczenia współrzędnej początkowej. Dla przykładu statek o długości 4 będzie miał współrzędne: „F4|F5|F6|F7”.
    11. Zmienne typu bool: „isSetPlayerShipCoor”, „isDirCoor”, „isDir”, „isBegAgn_FromDir”, „isCoor” i „isDone” pełnią swego rodzaju funkcję przełączników, które włączają i wyłączają z obiegu wywoływanie danych fragmentów kodu. Oto za co odpowiadają te bool’e:
       „isSetPlayerShipCoor” – komunikat o ustawieniu wszystkich statków dla danego gracz i reset wszystkich zmiennych związanych z ustawianiem wszystkich statków, aby można było je ustawić od nowa.
       „isDirCoor” – wyłączenie formularzy ustawiania kierunku oraz punktu współrzędnej początkowej statku i włącznie zapytania o zapisanie danych dotyczących pozycji statku.
       „isDir”– formularz dotyczący ustawiania kierunku statku.
       „isBegAgn_FromDir” – 
       „isCoor” – formularz dotyczący ustawiania punktu współrzędnej początkowej statku.
    12. „isDone” – jest zmienną przeznaczoną na prawidłowe wyświetlanie komunikatu „?” dla nieokreślonych współrzędnych dla danego statku w panelu ustawiania ich na planszy, a dokładniej w sekcji związanej w wyznaczaniem współrzędnej początkowej. Wartość ta odnosi się do sytuacji w której utworzony statek wraz ze współrzędnymi nie przeszedł walidacji współrzędnych. Zmienna ta pełni niemal tą samą funkcję co wartość pierwszego indeksu „shipFullCoor” wynosząca „?”, która odpowiada za wskazywanie zapytań które muszą być ponownie wykonane gdy wybrano złą współrzędną początkową, która to nie przeszła testów poprawności współrzędnych statku. Można by zadać pytanie dlaczego utworzono zmienną „isDone” dającą „taki” sam efekt. Powód użycia „isDone” jest bardzo złożony. „isDone” jak zostało wcześniej napisane odpowiada za prawidłowe wyświetlanie komunikatu „?” dla nieokreślonych współrzędnych dla danego statku w panelu informacyjnym ustawiania statków w sekcji wyznaczania współrzędnej początkowej. Gdyby użyto tam „shipFullCoor[0] = ”?””, wówczas podczas ponownego ustawiania współrzędnej początkowej w panelu informacyjnym w linii dotyczącej ustawionych współrzędnych zamiast znaku zapytania „?” znajdowałby się ciąg znaków „ | | …” w zależności od długości statku. Jest to najtrudniejsza do zrozumienia część działania kodu, ponieważ „shipFullCoor[0] = ”?”” i „isDone” odnoszą się do sytuacji w której utworzono złe współrzędne statku i następuje reset pętli odpowiedzialnej za zapytania odnośnie położenia tego statku. Ze względu na logikę warunków instrukcji warunkowych nie było możliwe zastosowanie wyłącznie operandu „shipFullCoor[0] = ”?” do wskazania kiedy wykonać odpowiednią operację, w tym operację pokazania znaku „?” w opisanej już sytuacji. Zmienna „isDone” ma zasadniczą właściwość, dzięki której można uzyskać pożądany efekt. Jest nią fakt, że nie jest zmienną „shipFullCoor[0] = ”?””, przez co nie ma tzw. kolizji wartości zmiennych i dzięki temu wykonywane są poprawne operacje we wszystkich warunkach instrukcji warunkowych.
    13. Zmienna string „firstCoor” zawiera wybrany przez gracza punkt współrzędnej początkowej, na podstawie której wyznaczane są pełne współrzędne statku, w zależności od ustalenia kierunku jego położenia.
    14. Zmienna string[] „shipFullCoor” przechowuje łańcuch znaków, który stanowi współrzędne położenia danego statku.
    15. Zmienna string „wantSave” służy jako wartość zapytania pytającego gracza czy chce zapisać dane położenia statku. Danymi tymi są przede wszystkim kierunek statku i jego już wyznaczone współrzędne. „wantSave” przyjmuje dwie wartości – „yes” i „no”. Jeżeli gracz zdecyduje się na zapisanie danych, wówczas na jego planszy pojawia się statek na tych polach planszy, jakie były opisane we współrzędnych. Jeśli natomiast gracz odmówi zapisania danych wybierając „no”, program powtórzy wszystkie operacje dla wyznaczania bieżącego statku. Wartością początkową jest „none”, która nie wpływa na nic.
    16. Tablica string[] „letCoorName” służy do przechowywania dużych liter, które są wyświetlane w iteracji pętli odpowiedzialnej za wyświetlanie pól planszy. Litery te znajdują się przed znakami pól planszy, a dokładniej przed znakami „|”.
Tak przedstawiają się w skrócie poszczególne zmienne. Przechodząc dalej do opisu działania metody „setPlayersShips” widzimy pętlę, wywołującą kod dla bieżącego gracza. Warunkiem zatrzymania pętli jest wartość zmiennej "players", wynosząca przynajmniej 2 (inkrementowanej oczywiście pod koniec), co oznacza, zakończenie wybierania statków dla ostatniego gracza. W pętli tej znajdują się odwołania do dwóch zmiennych z zakresu globalnego metody "setPlayersShips()" - "players" i "shipPage", które służą kolejno do przejścia do kolejnej serii („players”) zapytań o położenie statku („shipPage”) oraz do wyzerowania paneli informacyjnych odnośnie ustawiania statków. Następnie w ów pętli znajduje się kolejna pętla, która jest odpowiedzialna za powtarzanie kodu wyznaczania pozycji współrzędnych statku na planszy danego gracza. Kod ten jest powtarzany tyle razy, ile jest statków, czyli 7 dla każdego gracza z pętli nadrzędnej. Na końcu pętli nadrzędnej (graczy) znajduje się zwrócenie tablicy dwuwymiarowej, zawierające współrzędne poszczególnych statków graczy do zmiennej string[,] „playersShipCoorData_AR” metody "activeGameLoop" klasy "GameLoop".
Początkiem pętli potomnej (pozycjonowanie statków) jest wyświetlenie graficznej tablicy przedstawiającej planszę, na którą ustawiane są statki, aby pokazać graficznie gdzie dokładnie znajdują się. Dane w tablicy są wyświetlane za pomocą pętli „for”. Dla każdego przypada jedna plansza która jest wyświetlana względem zmiennej „players”, której wartości liczbowe 0 i 1 odpowiadają kolejno graczowi pierwszemu i drugiemu. Za tablicą znajdują się panel informacji dotyczący aktualnie ustawianego statku aktywowane za pomocą odpowiednich wartości powyżej podanych odpowiednich zmiennych typu bool. Następnie znajduje się informacja o ustawieniu wszystkich siedmiu statków na planszy. Informacja ta pojawia się tylko wtedy kiedy program przechodzi do początku zapytań i operacji ustawiania statków dla danego gracza. Później następuje ponowne wyświetlenie planszy, wraz z panelem informacyjnym. Można by zrobić to inaczej, ustalając tylko jedno wyświetlenie planszy wraz z panelem informacyjnym. Nie zdecydowano się na wybór tej opcji, gdyż utrudniłaby ona czytelność kodu i jego przejrzystość. Takich powtórzeń kodu w pętli jest 3, a odpowiadają one trzem następującym po sobie etapom: strona wprowadzająca → wyznaczanie kierunku → wyznaczanie współrzędnej początkowej, po których następuje ponowne działanie pętli na tym samym indeksie pętli ([i]), zablokowanie zapytać o kierunek i współrzędną oraz wyświetlenie zapytania o zapisanie danych. Każde z zapytań ma walidację wprowadzanych danych. Jeżeli wprowadzone dane nie będą poprawne, zmienna odpowiedzialna za inkrementację zmiennej pętli (statków) przyjmie wartość 0, co spowoduje, iż pętla nie przejdzie dalej do następnego statku, a wykona się ponownie wykonując komunikat o niepoprawnych danych. Są tutaj dwie ważne rzeczy. Wywoływanie kodu z pętli nie dotyka zapytani o współrzędne, gdyż są one zależne o wartości zmiennej „isCoor” typu bool. Podobnie jest z „isDir” odpowiadającej za zapytanie odnośnie wyznaczenia kierunku statku. Są to swego rodzaju przełączniki włączające i wyłączające określony przez nie kod z obiegu w pętli while (dotyczącej statków). W programie tym znajduje się duża ilość przełączników tego typu, gdyż zapotrzebowanie na tego typu funkcje jest duże w całej grze. Opuszczając teren zapytania o kierunek, program przechodzi do zapytania o wyznaczenie punktu początkowego współrzędnej statku. Wyznaczona współrzędna przechodzi krótki proces walidacji sprawdzający czy wybrana współrzędna ma odpowiednią długość znaków oraz czy istnieje na planszy. Jeżeli istnieje, jest transportowana do metody „shipCoorBuildChecker()”, klasy „ShipBuildChecker”, która tworzy dalsze współrzędne statku na podstawie wyznaczonego kierunku położenia statku, jego długości i wartości współrzędnej początkowej. Tworzone współrzędne statku, jak również współrzędna początkowa przechodzą proces walidacji, który określa czy statek:
    1. Nie wychodzi poza planszę.
    2. Nie nakłada się na inny statek.
Po pomyślnie zakończonych operacjach z metody „shipCoorBuildChecker()” zwracane są trzy zmienne w krotce (C# 7.0), którymi są następująco: współrzędne statku – „shipFullCoor”, zmodyfikowana (w metodzie „updateBoardContent()” po ustawieniu danego statku tablica pól planszy potrzebna do walidacji współrzędnych nowo tworzonego statku – „fullIndex_AR”, zmienna „isDone” określająca pozytywny wynik walidacji za pomocą wartości typu bool. Kolejnym krokiem jest wrzucenie poszczególnych współrzędnych statku do tablicy na współrzędne statków pojedynczego gracza, przemieniając oddzielne wartości współrzędnych w ciąg znaków: {„E4”, „F4”, „G4”} → {„E4|F4|G4”}, w którym każdą współrzędną rozdziela znak „|”. Po określeniu wszystkich danych niezbędnych do ustalenia statku wyskakuje zapytanie pytające się czy dany gracz chce zapisać współrzędne statku. Udzielenie pozytywnej odpowiedzi na to pytanie spowoduje, iż współrzędne zostaną przekazane dalej do metody „updateBoardContent()” klasy „BoardContentMaker”, w której dochodzi modyfikacji graficznej tablicy planszy, na której pojawia się nowy statek – „playersBoardContent_AR” oraz do modyfikacji tablicy pól planszy potrzebnej do walidacji współrzędnych nowo tworzonego statku – „fullIndex_AR”. Obydwie te tablice są oczywiście zwracane z tej metody w zaktualizowanej formie. Kiedy gracz nie zdecyduje się zapisać danych, pętla odpowiedzialna za zapytania i operacje odnośnie ustawiania statku odtwarzana jest od nowa, przez co gracz musi od nowa wybrać dane do ustalenia pozycji statku. Wybierając pierwszą lub drugą opcję zresetowane zostaną wszystkie dane, związane z zapytaniami i operacjami odnośnie ustawiania statku. Na końcu tej metody („setPlayersShips()”) znajdują się instrukcja warunkowa zawierająca dwa komunikaty dla odpowiednich graczy, którzy ustawili swoje statki na swoich planszach.
Metoda „fight()” klasy „GameProper” odpowiada za wyświetlanie zapytań i przeprowadzanie operacji związanych z logiką bitwy gry. Wywołanie tej metody następuje, gdy gracze ustawią swoje statki. Metoda ta ma jeden parametr, którym jest tablica przechowująca współrzędne statków graczy. Na początku metody „fight()” znajduje się deklaracja głównych zmiennych, które odpowiadają kolejno za przechowywanie współrzędnych statków dla danego gracza w tablicy typu string[,] w formie łańcuchów znaków oraz za przechowywanie informacji o zwycięzcy. Za nimi znajdują się zmienne, które tworzą tablicę List<List<List<string>>>, zawierającą współrzędne statków graczy. Jej struktura wygląda tak: gracz → statek → współrzędne → współrzędna. Dalej znajduje się tablica dynamiczna do której wkładane są współrzędne skonwertowane z tablicy typu string[]. Ostatnią zmienną jest tablica string[] do której wkładane są przetworzone współrzędne typu „A2”, „B2”, „C2” z „A2|B2|C2”. Na początku działania metody „fight()” po deklaracji zmiennych współrzędne typu „A2|B2|C2” konwertowane są do postaci „A2”, „B2”, „C2” oraz wkładane do tablicy innego typu – List<List<List<string>>>. Użyto tu tego typu, gdyż do logiki bitwy potrzebne są współrzędne, z których każda jest oddzielona od siebie i włożona jako poszczególny indeks najbardziej zagnieżdżonej tablicy należącej do List<List<List<string>>>. W tej części metody „fight()” klasy „GameProper” użyta jest metoda „Split()” obiektu Array w celu rozdzielenia współrzędnych „A2|B2|C2” na „A2”, „B2”, „C2” w łańcuchu znaków i władowania ich do zmiennej string[]. Argumentem metody „Split()” jest „|”. Pod spodem znajduje się znajduje się kombinacja metod „Select(x => x.ToString()).ToList()”, która konwertuje dane z tablicy string[] do tablicy List<string>, w celu umożliwienia włożenia tej tablicy do odpowiedniej tablicy dwuwymiarowej List<List<string>>. Metoda „ToString()” określa typ zmiennych (tutaj string). Na końcu dane tablica List<List<string>> jest wkładana do tablicy trójwymiarowej List<List<List<.string>>>. Następną operacją w metodzie „fight()” jest utworzenie tablicy o strukturze odpowiadającej tablicy przechowującej skonwertowane współrzędne typu „A2”, „B2”, „C2”. W zasadzie jest to jej klon, tylko z tą różnicą, iż zamiast wartości współrzędnych znajdują się tam wartości „??”. Tablica ta jest używana w panelu informacyjnym podczas bitwy, w którym znajdują się wypunktowane współrzędne poszczególnych statków. Kolejną operacją metody „fight()” jest skonwertowanie danych typu „C2” na dane typu liczbowego: „22” i zamianę ich typu zmiennych string na typ int – 22 poprzez wrzucenie ich do nowej tablicy z tym właśnie typem, używając metody „int.Parse()”., aby można było bez problemu użyć ich do logiki strzelania metody „fire” klasy „ShipCannon”. Następnie są deklarowane zmienne potrzebne do przeprowadzania zapytań odnośnie bitwy. Są to:
1. Zmienne typu bool podobnie jak w metodzie „setPlayersShips()” odpowiadają za włączanie i wyłączanie fragmętów kodu z obiegu pętli znajdującej się poniżej tych zmiennych. Odpowiadają one kolejno za:
„isFight” – działanie pętli.

„isPlayerChoose” – wybór gracza.
„isReturn” – zatrzymanie się wykonywania programu na tym samym graczu, kiedy poda on niepoprawną współrzędną oraz współrzędną, którą już wcześniej podał.
„isWinner” – określenie zwycięzcy.
2. Zmienna „attackPlayer” typu int zawiera liczbę określającą gracza, który jest atakowany.
3. Zmienna „gamePlayer” typu int zawiera liczbę określającą gracza, który atakuje swojego przeciwnika.
4. Zmienna „playerReadLine” typu string przechowuje wartość, określającą gracza, który zaczyna bitwę jako pierwszy.
5. Tablica typu string[,,] „playersBoardFight_AR” przechowuje stan plansz obu graczy podczas bitwy. Przyjmuje trzy wartości. Są nimi: początkowy znak „~” dla pól, które nie zostały ostrzeliwane, „X” dla pól na które przeprowadzono ostrzał i uszkodzono statek oraz „O”, które ostrzelano, ale nie nie trafiono w statek.
6. Lista List<List<int>> „playersBoardFight_intToSplice_AR”przechowująca współrzędne liczbowe poszczególnych plansz dla danego gracza. Jest ona wykorzystywana do przeprowadzenia poprawnej walidacji w określeniu zgodności ostrzeliwanego pola względem możliwego znajdowania się tam części statku.
Na początku pętli odpowiedzialnej za przeprowadzenie bitwy wyświetlane są plansze współrzędnych obu graczy. Pod nimi wyświetlane są informacje o statkach graczy, zawierające na początku wartości „??”. Wartości te znajdują się w trójwymiarowej liście o strukturze: gracz → statek → współrzędne → współrzędna. Dane te wyświetlane są względem graczy, tzn. dla gracza pierwszego są wyświetlane informacje o jego statkach. Tak samo jest w przypadku drugiego gracza. Wszystkie te zestawy danych są wyświetlane przy użyciu jednej pętli „for”. Statki obu graczy są rozdzielane od siebie odstępami odpowiedniej długości, względem długości przestrzeni zajmowanej przez wyświetlenie współrzędnych statków graczy. Przykładowo dla statków o długości 5 współrzędnych odstęp będzie mały, a przy statkach o długości 2 współrzędnych odstęp będzie duży. Decyzja o długości odstępu jest podejmowana w warunku instrukcji „switch”, która w tym przypadku skraca kod w przypadku użycia instrukcji „if/else” oraz przede wszystkim zwiększa czytelność kodu. Kiedy gracz zostanie wybrany, fragemnt kodu odpowiedzialny za to zapytanie i operacje z nim związane jest wyłączany z obiegu pętli. Włączony do obiegu zostaje kod, który jest odpowiedzialny za przeprowadzenie bitwy. Na początku tego kodu zmienna „attackPlayer” ma zmienianą wartość. Jeżeli wynosi 0, przyjmuje wartość 1, a jeśli wynosi 1, przyjmuje wartość 0. Zabieg ten ma na celu określenie wroga gracza, który rozpoczął pojedynek. Dzieje się tak, gdyż przed tą operacją zmienna „gamePlayer” przyjmuje wartość zmiennej „attackPlayer” – zmienne te mają wtedy taką samą wartość. W związku z tym faktem, jeżeli wartość „attackPlayer” nie uległaby zmianie, gracz atakujący swojego wroga w praktyce atakowałby samego siebie. Po tej operacji znajduje się zapytanie o wybór gracza, który zacznie bitwę. Po wyborze gracza następuje bitwa w której gracze strzelają na przemian do siebie w celu zatopienia wszystkich statków swojego przeciwnika. Dany gracz jest wówczas proszony o podanie współrzędnej pola planszy przeciwnika, które chce zaatakować. Po podaniu współrzędnej tego pola przechodzi ona pierwszy proces walidacji, gdzie sprawdzane jest czy współrzędna ta nie ma pustej wartości i czy ma odpowiednią długość. Po udanym pierwszym procesie wartość współrzędnej jest konwertowana z typu wartości „C2” na „22” i przechodzi drugi proces walidacji polegający na sprawdzeniu czy wartość ta pole to istnieje na planszy wroga oraz czy współrzędna ta nie została już wcześniej wybrana.. Po pomyślnym wyniku, współrzędna ta wkładana jest to metody „fire()” klasy”ShipCannon”, jako jeden z jej siedmiu argumentów.

 wkładana jako jeden z argumentów metody „fire()” klasy „ShipCannon”.

STRONA 970





UWAGA!!!! ZMIEŃ OKREŚLENIE !!!TABLICA!!! W ODNIESIENIU DO !!!LIST!!! NA !!!LISTA!!!












































11. Klasa "Prize"

12. Klasa "BoardContentMaker"

13. Klasa "ShipBuildChecker"

14. Klasa "ShipCannon"

15. Klasa "GameCredits":
Klasa"GameCredits" zawiera tylko jedną metodę. Jest nią "showCredits()", która wyświetla napis "GAME CREDITS", składający się ze znaków "B", za pod nim podziękowanie za grę, wraz z informacją o autorze gry. Na dole znajduje się komunikat, informujący o końcu programu, który nastąpi, jeśli zostanie naciśnięty klawisz "Enter".

16. Testy:
Program ten był wielokrotnie testowany na różnych etapach produkcji. Celem testów było sprawdzenie poprawności działania programu i znalezienie wszystkich możliwych do wystąpienia błędów, z zamiarem likwidacji ich. W celu osiągnięcia jak największej wydajności pracy oraz związanego z tym zminimalizowania występowania błędów, program był często poddawany testom jednostkowym, poszczególnych części metod danych klas i finalnie przy testowaniu działania całych metod oraz zwracania z nich przetworzonych (w nich) zmiennych do innych metod tej samej klasy. Testy były przeprowadzane  niemal co 20 linii kodu, więc nie ma sensu opisywać co zostało przetestowane, jak przebiegał ten test, jakie były jego założenia. Ważniejszym punktem jest sposób, a dokładniej idea przeprowadzania tych testów. 
Wszystkie testy pyły przeprowadzane na podstawie wyświetlania w konsoli określonych danych, na podstawie których było stwierdzane, czy program działa poprawnie, oczywiście we wszystkich możliwych przypadkach wystąpienia tych danych. Dane były przekazywane w dwóch formach. Pierwszą z  nich był zwykły komunikat „Console.WrieLine()” z określoną w środku wartością, poprzedzany oczywiście wykasowaniem zawartości okna konsoli za pomocą „Console.Clear()” oraz znajdującym się na końcu komunikatem o kontynuowaniu gry z „Console.ReadLine()”. Drugą formą testów było wyświetlanie danych z danej tabeli za pomocą pętli „for” (w tym także zagnieżdżonych) w celu sprawdzenia ich poprawności względem oczekiwanych wyników.

Linie kodu odpowiedzialne za testy zostały usunięte, z powodu przejścia przez program wszystkich testów oraz w celu zwiększenia czytelności kodu.

17. Bibliografia:
Do utworzenia programu użyto wiedzy z następujących źródeł:
C# 9.0 Leksykon Kieszonkowy – Joseph Albahari, Ben Albahari
C# Praktyczny kurs – Marcin Lis (wydanie 3)
